{"mappings":"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","sources":["<anon>","js/battle-dex-search.js"],"sourcesContent":["/**\n * Search\n *\n * Code for searching for dex information\n *\n *\n * @author Guangcong Luo <guangcongluo@gmail.com>\n * @license MIT\n */ /** ID, SearchType, index (if alias), offset (if offset alias) */ let $cd61f496984300fe$var$BattleSearchIndex = [];\nlet $cd61f496984300fe$var$BattleSearchIndexOffset;\nfunction $cd61f496984300fe$var$hasAbility(pokemon, ability) {\n    for(let key in pokemon.abilities){\n        if (toID(pokemon.abilities[key]) == toID(ability)) return true;\n    }\n    return false;\n}\nfunction $cd61f496984300fe$var$generateSearchIndex() {\n    let index = [];\n    index = index.concat(Object.keys(BattlePokedex).map((x)=>x + \" pokemon\"));\n    index = index.concat(Object.keys(BattleMovedex).map((x)=>x + \" move\"));\n    index = index.concat(Object.keys(BattleItems).map((x)=>x + \" item\"));\n    index = index.concat(Object.keys(BattleAbilities).map((x)=>x + \" ability\"));\n    index = index.concat(Object.keys(BattleTypeChart).map((x)=>toID(x) + \" type\"));\n    index = index.concat([\n        \"physical\",\n        \"special\",\n        \"status\"\n    ].map((x)=>toID(x) + \" category\"));\n    index = index.concat([\n        \"monster\",\n        \"water1\",\n        \"bug\",\n        \"flying\",\n        \"field\",\n        \"fairy\",\n        \"grass\",\n        \"humanlike\",\n        \"water3\",\n        \"mineral\",\n        \"amorphous\",\n        \"water2\",\n        \"ditto\",\n        \"dragon\",\n        \"undiscovered\"\n    ].map((x)=>toID(x) + \" egggroup\"));\n    index.sort();\n    // manually rearrange\n    index[index.indexOf(\"grass type\")] = \"grass egggroup\";\n    index[index.indexOf(\"grass egggroup\")] = \"grass type\";\n    index[index.indexOf(\"fairy type\")] = \"fairy egggroup\";\n    index[index.indexOf(\"fairy egggroup\")] = \"fairy type\";\n    index[index.indexOf(\"flying type\")] = \"flying egggroup\";\n    index[index.indexOf(\"flying egggroup\")] = \"flying type\";\n    index[index.indexOf(\"dragon type\")] = \"dragon egggroup\";\n    index[index.indexOf(\"dragon egggroup\")] = \"dragon type\";\n    index[index.indexOf(\"bug type\")] = \"bug egggroup\";\n    index[index.indexOf(\"bug egggroup\")] = \"bug type\";\n    index[index.indexOf(\"psychic type\")] = \"psychic move\";\n    index[index.indexOf(\"psychic move\")] = \"psychic type\";\n    if (getID(BattlePokedex, \"ditto\")) {\n        index[index.indexOf(\"ditto pokemon\")] = \"ditto egggroup\";\n        index[index.indexOf(\"ditto egggroup\")] = \"ditto pokemon\";\n    }\n    $cd61f496984300fe$var$BattleSearchIndex = index.map((x)=>{\n        let split = x.split(\" \");\n        if (split.length > 3) {\n            split[3] = Number(split[3]);\n            split[2] = index.indexOf(split[2] + \" \" + split[1]);\n        }\n        return split;\n    });\n    $cd61f496984300fe$var$BattleSearchIndexOffset = $cd61f496984300fe$var$BattleSearchIndex.map((entry, i)=>{\n        var _a, _b, _c, _d;\n        const id = entry[0];\n        let name = \"\";\n        switch(entry[1]){\n            case \"pokemon\":\n                name = (_a = getID(BattlePokedex, id).name) !== null && _a !== void 0 ? _a : \"\";\n                break;\n            case \"move\":\n                name = (_b = getID(BattleMovedex, id).name) !== null && _b !== void 0 ? _b : \"\";\n                break;\n            case \"item\":\n                name = (_c = getID(BattleItems, id).name) !== null && _c !== void 0 ? _c : \"\";\n                break;\n            case \"ability\":\n                name = (_d = getID(BattleAbilities, id).name) !== null && _d !== void 0 ? _d : \"\";\n                break;\n        }\n        let res = \"\";\n        let nonAlnum = 0;\n        for(let i = 0, j = 0; i < id.length; i++, j++){\n            while(!/[a-zA-Z0-9]/.test(name[j])){\n                j++;\n                nonAlnum++;\n            }\n            res += nonAlnum;\n        }\n        if (nonAlnum) return res;\n        return \"\";\n    });\n}\n/**\n * Backend for search UIs.\n */ class $cd61f496984300fe$var$DexSearch {\n    constructor(searchType = \"\", formatid = \"\", species = \"\"){\n        this.query = \"\";\n        this.typedSearch = null;\n        this.results = null;\n        this.exactMatch = false;\n        this.firstPokemonColumn = \"Number\";\n        /**\n         * Column to sort by. Default is `null`, a smart sort determined by how good\n         * things are according to the base filters, falling back to dex number (for\n         * Pokemon) and name (for everything else).\n         */ this.sortCol = null;\n        this.reverseSort = false;\n        /**\n         * Filters for the search result. Does not include the two base filters\n         * (format and species).\n         */ this.filters = null;\n        $cd61f496984300fe$var$generateSearchIndex();\n        this.setType(searchType, formatid, species);\n    }\n    getTypedSearch(searchType, format = \"\", speciesOrSet) {\n        if (!searchType) return null;\n        switch(searchType){\n            case \"pokemon\":\n                return new $cd61f496984300fe$var$BattlePokemonSearch(\"pokemon\", format, speciesOrSet);\n            case \"item\":\n                return new $cd61f496984300fe$var$BattleItemSearch(\"item\", format, speciesOrSet);\n            case \"move\":\n                return new $cd61f496984300fe$var$BattleMoveSearch(\"move\", format, speciesOrSet);\n            case \"ability\":\n                return new $cd61f496984300fe$var$BattleAbilitySearch(\"ability\", format, speciesOrSet);\n            case \"type\":\n                return new $cd61f496984300fe$var$BattleTypeSearch(\"type\", format, speciesOrSet);\n            case \"category\":\n                return new $cd61f496984300fe$var$BattleCategorySearch(\"category\", format, speciesOrSet);\n        }\n        return null;\n    }\n    find(query) {\n        var _a;\n        query = toID(query);\n        if (this.query === query && this.results) return false;\n        this.query = query;\n        if (!query) this.results = ((_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.getResults(this.filters, this.sortCol, this.reverseSort)) || [];\n        else this.results = this.textSearch(query);\n        return true;\n    }\n    setType(searchType, format = \"\", speciesOrSet) {\n        var _a;\n        // invalidate caches\n        this.results = null;\n        if (searchType !== ((_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.searchType)) {\n            this.filters = null;\n            this.sortCol = null;\n        }\n        this.typedSearch = this.getTypedSearch(searchType, format, speciesOrSet);\n    }\n    addFilter(entry) {\n        if (!this.typedSearch) return false;\n        let [type] = entry;\n        if (this.typedSearch.searchType === \"pokemon\") {\n            if (type === this.sortCol) this.sortCol = null;\n            if (![\n                \"type\",\n                \"move\",\n                \"ability\",\n                \"egggroup\",\n                \"tier\"\n            ].includes(type)) return false;\n            if (type === \"move\") entry[1] = toID(entry[1]);\n            if (!this.filters) this.filters = [];\n            this.results = null;\n            for (const filter of this.filters){\n                if (filter[0] === type && filter[1] === entry[1]) return true;\n            }\n            this.filters.push(entry);\n            return true;\n        } else if (this.typedSearch.searchType === \"move\") {\n            if (type === this.sortCol) this.sortCol = null;\n            if (![\n                \"type\",\n                \"category\",\n                \"pokemon\"\n            ].includes(type)) return false;\n            if (type === \"pokemon\") entry[1] = toID(entry[1]);\n            if (!this.filters) this.filters = [];\n            this.filters.push(entry);\n            this.results = null;\n            return true;\n        }\n        return false;\n    }\n    removeFilter(entry) {\n        if (!this.filters) return false;\n        if (entry) {\n            const filterid = entry.join(\":\");\n            let deleted = null;\n            // delete specific filter\n            for(let i = 0; i < this.filters.length; i++)if (filterid === this.filters[i].join(\":\")) {\n                deleted = this.filters[i];\n                this.filters.splice(i, 1);\n                break;\n            }\n            if (!deleted) return false;\n        } else this.filters.pop();\n        if (!this.filters.length) this.filters = null;\n        this.results = null;\n        return true;\n    }\n    toggleSort(sortCol) {\n        if (this.sortCol === sortCol) {\n            if (!this.reverseSort) this.reverseSort = true;\n            else {\n                this.sortCol = null;\n                this.reverseSort = false;\n            }\n        } else {\n            this.sortCol = sortCol;\n            this.reverseSort = false;\n        }\n        this.results = null;\n    }\n    filterLabel(filterType) {\n        if (this.typedSearch && this.typedSearch.searchType !== filterType) return \"Filter\";\n        return null;\n    }\n    illegalLabel(id) {\n        var _a, _b;\n        return ((_b = (_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.illegalReasons) === null || _b === void 0 ? void 0 : _b[id]) || null;\n    }\n    textSearch(query) {\n        var _a, _b, _c;\n        query = toID(query);\n        this.exactMatch = false;\n        let searchType = ((_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.searchType) || \"\";\n        // If searchType exists, we're searching mainly for results of that type.\n        // We'll still search for results of other types, but those results\n        // will only be used to filter results for that type.\n        let searchTypeIndex = searchType ? $cd61f496984300fe$var$DexSearch.typeTable[searchType] : -1;\n        /** searching for \"Psychic type\" will make the type come up over the move */ let qFilterType = \"\";\n        if (query.slice(-4) === \"type\") {\n            if (query.slice(0, -4) in BattleTypeChart) {\n                query = query.slice(0, -4);\n                qFilterType = \"type\";\n            }\n        }\n        // i represents the location of the search index we're looking at\n        let i = $cd61f496984300fe$var$DexSearch.getClosest(query);\n        this.exactMatch = $cd61f496984300fe$var$BattleSearchIndex[i][0] === query;\n        // Even with output buffer buckets, we make multiple passes through\n        // the search index. searchPasses is a queue of which pass we're on:\n        // [passType, i, query]\n        // By doing an alias pass after the normal pass, we ensure that\n        // mid-word matches only display after start matches.\n        let passType = \"\";\n        let searchPasses = [\n            [\n                \"normal\",\n                i,\n                query\n            ]\n        ];\n        // For performance reasons, only do an alias pass if query is at\n        // least 2 chars long\n        if (query.length > 1) searchPasses.push([\n            \"alias\",\n            i,\n            query\n        ]);\n        // If there are no matches starting with query: Do a fuzzy match pass\n        // Fuzzy matches will still be shown after alias matches\n        if (!this.exactMatch && $cd61f496984300fe$var$BattleSearchIndex[i][0].substr(0, query.length) !== query) {\n            // No results start with this. Do a fuzzy match pass.\n            let matchLength = query.length - 1;\n            if (!i) i++;\n            while(matchLength && $cd61f496984300fe$var$BattleSearchIndex[i][0].substr(0, matchLength) !== query.substr(0, matchLength) && $cd61f496984300fe$var$BattleSearchIndex[i - 1][0].substr(0, matchLength) !== query.substr(0, matchLength))matchLength--;\n            let matchQuery = query.substr(0, matchLength);\n            while(i >= 1 && $cd61f496984300fe$var$BattleSearchIndex[i - 1][0].substr(0, matchLength) === matchQuery)i--;\n            searchPasses.push([\n                \"fuzzy\",\n                i,\n                \"\"\n            ]);\n        }\n        // We split the output buffers into 8 buckets.\n        // Bucket 0 is usually unused, and buckets 1-7 represent\n        // pokemon, types, moves, etc (see typeTable).\n        // When we're done, the buffers are concatenated together to form\n        // our results, with each buffer getting its own header, unlike\n        // multiple-pass results, which have no header.\n        // Notes:\n        // - if we have a searchType, that searchType's buffer will be on top\n        let bufs = [\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            []\n        ];\n        let topbufIndex = -1;\n        let count = 0;\n        let nearMatch = false;\n        /** [type, id, typeIndex] */ let instafilter = null;\n        let instafilterSort = [\n            0,\n            1,\n            2,\n            5,\n            4,\n            3,\n            6,\n            7,\n            8\n        ];\n        let illegal = (_b = this.typedSearch) === null || _b === void 0 ? void 0 : _b.illegalReasons;\n        // We aren't actually looping through the entirety of the searchIndex\n        for(i = 0; i < $cd61f496984300fe$var$BattleSearchIndex.length; i++){\n            if (!passType) {\n                let searchPass = searchPasses.shift();\n                if (!searchPass) break;\n                passType = searchPass[0];\n                i = searchPass[1];\n                query = searchPass[2];\n            }\n            let entry = $cd61f496984300fe$var$BattleSearchIndex[i];\n            let id = entry[0];\n            let type = entry[1];\n            if (!id) break;\n            if (passType === \"fuzzy\") {\n                // fuzzy match pass; stop after 2 results\n                if (count >= 2) {\n                    passType = \"\";\n                    continue;\n                }\n                nearMatch = true;\n            } else if (passType === \"exact\") // exact pass; stop after 1 result\n            {\n                if (count >= 1) {\n                    passType = \"\";\n                    continue;\n                }\n            } else if (id.substr(0, query.length) !== query) {\n                // regular pass, time to move onto our next match\n                passType = \"\";\n                continue;\n            }\n            if (entry.length > 2) {\n                // alias entry\n                if (passType !== \"alias\") continue;\n            } else {\n                // normal entry\n                if (passType === \"alias\") continue;\n            }\n            let typeIndex = $cd61f496984300fe$var$DexSearch.typeTable[type];\n            // For performance, with a query length of 1, we only fill the first bucket\n            if (query.length === 1 && typeIndex !== (searchType ? searchTypeIndex : 1)) continue;\n            // For pokemon queries, accept types/tier/abilities/moves/eggroups as filters\n            if (searchType === \"pokemon\" && (typeIndex === 5 || typeIndex > 7)) continue;\n            // For move queries, accept types/categories as filters\n            if (searchType === \"move\" && (typeIndex !== 8 && typeIndex > 4 || typeIndex === 3)) continue;\n            // For move queries in the teambuilder, don't accept pokemon as filters\n            if (searchType === \"move\" && illegal && typeIndex === 1) continue;\n            // For ability/item queries, don't accept anything else as a filter\n            if ((searchType === \"ability\" || searchType === \"item\") && typeIndex !== searchTypeIndex) continue;\n            // Query was a type name followed 'type'; only show types\n            if (qFilterType === \"type\" && typeIndex !== 2) continue;\n            // hardcode cases of duplicate non-consecutive aliases\n            if ((id === \"megax\" || id === \"megay\") && \"mega\".startsWith(query)) continue;\n            let matchStart = 0;\n            let matchEnd = 0;\n            if (passType === \"alias\") {\n                // alias entry\n                // [aliasid, type, originalid, matchStart, originalindex]\n                matchStart = entry[3];\n                let originalIndex = entry[2];\n                if (matchStart) {\n                    matchEnd = matchStart + query.length;\n                    matchStart += ($cd61f496984300fe$var$BattleSearchIndexOffset[originalIndex][matchStart] || \"0\").charCodeAt(0) - 48;\n                    matchEnd += ($cd61f496984300fe$var$BattleSearchIndexOffset[originalIndex][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n                }\n                id = $cd61f496984300fe$var$BattleSearchIndex[originalIndex][0];\n            } else {\n                matchEnd = query.length;\n                if (matchEnd) matchEnd += ($cd61f496984300fe$var$BattleSearchIndexOffset[i][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n            }\n            if (searchType && searchTypeIndex !== typeIndex) // This is a filter, set it as an instafilter candidate\n            {\n                if (!instafilter || instafilterSort[typeIndex] < instafilterSort[instafilter[2]]) instafilter = [\n                    type,\n                    id,\n                    typeIndex\n                ];\n            }\n            // show types above Arceus formes\n            if (topbufIndex < 0 && searchTypeIndex < 2 && passType === \"alias\" && !bufs[1].length && bufs[2].length) topbufIndex = 2;\n            if (illegal && typeIndex === searchTypeIndex) {\n                // Always show illegal results under legal results.\n                // This is done by putting legal results (and the type header)\n                // in bucket 0, and illegal results in the searchType's bucket.\n                // searchType buckets are always on top (but under bucket 0), so\n                // illegal results will be seamlessly right under legal results.\n                if (!bufs[typeIndex].length && !bufs[0].length) bufs[0] = [\n                    [\n                        \"header\",\n                        $cd61f496984300fe$var$DexSearch.typeName[type]\n                    ]\n                ];\n                if (!(id in illegal)) typeIndex = 0;\n            } else if (!bufs[typeIndex].length) bufs[typeIndex] = [\n                [\n                    \"header\",\n                    $cd61f496984300fe$var$DexSearch.typeName[type]\n                ]\n            ];\n            // don't match duplicate aliases\n            let curBufLength = passType === \"alias\" && bufs[typeIndex].length;\n            if (curBufLength && bufs[typeIndex][curBufLength - 1][1] === id) continue;\n            bufs[typeIndex].push([\n                type,\n                id,\n                matchStart,\n                matchEnd\n            ]);\n            count++;\n        }\n        let topbuf = [];\n        if (nearMatch) topbuf = [\n            [\n                \"html\",\n                `<em>No exact match found. The closest matches alphabetically are:</em>`\n            ]\n        ];\n        if (topbufIndex >= 0) {\n            topbuf = topbuf.concat(bufs[topbufIndex]);\n            bufs[topbufIndex] = [];\n        }\n        if (searchTypeIndex >= 0) {\n            topbuf = topbuf.concat(bufs[0]);\n            topbuf = topbuf.concat(bufs[searchTypeIndex]);\n            bufs[searchTypeIndex] = [];\n            bufs[0] = [];\n        }\n        if (instafilter && count < 20) // Result count is less than 20, so we can instafilter\n        bufs.push(this.instafilter(searchType, instafilter[0], instafilter[1]));\n        this.results = Array.prototype.concat.apply(topbuf, bufs);\n        return (_c = this.results) !== null && _c !== void 0 ? _c : [];\n    }\n    instafilter(searchType, fType, fId) {\n        var _a;\n        let buf = [];\n        let illegalBuf = [];\n        let illegal = (_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.illegalReasons;\n        if (searchType === \"pokemon\") switch(fType){\n            case \"type\":\n                let type = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${type}-type Pok&eacute;mon`\n                ]);\n                for(let id in BattlePokedex){\n                    if (!BattlePokedex[id].types) continue;\n                    if (BattlePokedex[id].types.includes(type)) (illegal && id in illegal ? illegalBuf : buf).push([\n                        \"pokemon\",\n                        id\n                    ]);\n                }\n                break;\n            case \"ability\":\n                let ability = getID(BattleAbilities, fId).name;\n                buf.push([\n                    \"header\",\n                    `${ability} Pok&eacute;mon`\n                ]);\n                for(let id in BattlePokedex){\n                    if (!BattlePokedex[id].abilities) continue;\n                    if ($cd61f496984300fe$var$hasAbility(BattlePokedex[id], ability)) (illegal && id in illegal ? illegalBuf : buf).push([\n                        \"pokemon\",\n                        id\n                    ]);\n                }\n                break;\n        }\n        else if (searchType === \"move\") switch(fType){\n            case \"type\":\n                let type1 = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${type1}-type moves`\n                ]);\n                for(let id in BattleMovedex)if (BattleMovedex[id].type === type1) (illegal && id in illegal ? illegalBuf : buf).push([\n                    \"move\",\n                    id\n                ]);\n                break;\n            case \"category\":\n                let category = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${category} moves`\n                ]);\n                for(let id in BattleMovedex)if (BattleMovedex[id].category === category) (illegal && id in illegal ? illegalBuf : buf).push([\n                    \"move\",\n                    id\n                ]);\n                break;\n        }\n        return [\n            ...buf,\n            ...illegalBuf\n        ];\n    }\n    static getClosest(query) {\n        // binary search through the index!\n        let left = 0;\n        let right = $cd61f496984300fe$var$BattleSearchIndex.length - 1;\n        while(right > left){\n            let mid = Math.floor((right - left) / 2 + left);\n            if ($cd61f496984300fe$var$BattleSearchIndex[mid][0] === query && (mid === 0 || $cd61f496984300fe$var$BattleSearchIndex[mid - 1][0] !== query)) // that's us\n            return mid;\n            else if ($cd61f496984300fe$var$BattleSearchIndex[mid][0] < query) left = mid + 1;\n            else right = mid - 1;\n        }\n        if (left >= $cd61f496984300fe$var$BattleSearchIndex.length - 1) left = $cd61f496984300fe$var$BattleSearchIndex.length - 1;\n        else if ($cd61f496984300fe$var$BattleSearchIndex[left + 1][0] && $cd61f496984300fe$var$BattleSearchIndex[left][0] < query) left++;\n        if (left && $cd61f496984300fe$var$BattleSearchIndex[left - 1][0] === query) left--;\n        return left;\n    }\n}\n$cd61f496984300fe$var$DexSearch.typeTable = {\n    pokemon: 1,\n    type: 2,\n    tier: 3,\n    move: 4,\n    item: 5,\n    ability: 6,\n    egggroup: 7,\n    category: 8,\n    article: 9\n};\n$cd61f496984300fe$var$DexSearch.typeName = {\n    pokemon: \"Pok&eacute;mon\",\n    type: \"Type\",\n    tier: \"Tiers\",\n    move: \"Moves\",\n    item: \"Items\",\n    ability: \"Abilities\",\n    egggroup: \"Egg group\",\n    category: \"Category\",\n    article: \"Article\"\n};\nclass $cd61f496984300fe$var$BattleTypedSearch {\n    constructor(searchType, format = \"\", speciesOrSet = \"\"){\n        /**\n         * `species` is the second of two base filters. It constrains results to\n         * things that species can use, and affects the default sort.\n         */ this.species = \"\";\n        /**\n         * `set` is a pseudo-base filter; it has minor effects on move sorting.\n         * (Abilities/items can affect what moves are sorted as usable.)\n         */ this.set = null;\n        /**\n         * Cached copy of what the results list would be with only base filters\n         * (i.e. with an empty `query` and `filters`)\n         */ this.baseResults = null;\n        /**\n         * Cached copy of all results not in `baseResults` - mostly in case a user\n         * is wondering why a specific result isn't showing up.\n         */ this.baseIllegalResults = null;\n        this.illegalReasons = null;\n        this.results = null;\n        this.sortRow = null;\n        this.searchType = searchType;\n        this.baseResults = null;\n        this.baseIllegalResults = null;\n        this.species = \"\";\n        this.set = null;\n        if (typeof speciesOrSet === \"string\") {\n            if (speciesOrSet) this.species = speciesOrSet;\n        } else {\n            this.set = speciesOrSet;\n            this.species = toID(this.set.species);\n        }\n        if (!searchType || !this.set) return;\n    }\n    getResults(filters, sortCol, reverseSort) {\n        if (sortCol === \"type\") return [\n            this.sortRow,\n            ...$cd61f496984300fe$var$BattleTypeSearch.prototype.getDefaultResults.call(this)\n        ];\n        else if (sortCol === \"category\") return [\n            this.sortRow,\n            ...$cd61f496984300fe$var$BattleCategorySearch.prototype.getDefaultResults.call(this)\n        ];\n        else if (sortCol === \"ability\") return [\n            this.sortRow,\n            ...$cd61f496984300fe$var$BattleAbilitySearch.prototype.getDefaultResults.call(this)\n        ];\n        if (!this.baseResults) this.baseResults = this.getBaseResults();\n        if (!this.baseIllegalResults) {\n            const legalityFilter = {};\n            for (const [resultType, value] of this.baseResults)if (resultType === this.searchType) legalityFilter[value] = 1;\n            this.baseIllegalResults = [];\n            this.illegalReasons = {};\n            for(const id in this.getTable())if (!(id in legalityFilter)) {\n                this.baseIllegalResults.push([\n                    this.searchType,\n                    id\n                ]);\n                this.illegalReasons[id] = \"Illegal\";\n            }\n        }\n        let results;\n        let illegalResults;\n        if (filters) {\n            results = [];\n            illegalResults = [];\n            for (const result of this.baseResults)if (this.filter(result, filters)) {\n                if (results.length && result[0] === \"header\" && results[results.length - 1][0] === \"header\") results[results.length - 1] = result;\n                else results.push(result);\n            }\n            if (results.length && results[results.length - 1][0] === \"header\") results.pop();\n            for (const result of this.baseIllegalResults)if (this.filter(result, filters)) illegalResults.push(result);\n        } else {\n            results = [\n                ...this.baseResults\n            ];\n            illegalResults = null;\n        }\n        if (sortCol) {\n            results = results.filter(([rowType])=>rowType === this.searchType);\n            results = this.sort(results, sortCol, reverseSort);\n            if (illegalResults) {\n                illegalResults = illegalResults.filter(([rowType])=>rowType === this.searchType);\n                illegalResults = this.sort(illegalResults, sortCol, reverseSort);\n            }\n        }\n        if (this.sortRow) results = [\n            this.sortRow,\n            ...results\n        ];\n        if (illegalResults && illegalResults.length) results = [\n            ...results,\n            [\n                \"header\",\n                \"Illegal results\"\n            ],\n            ...illegalResults\n        ];\n        return results;\n    }\n}\nclass $cd61f496984300fe$var$BattlePokemonSearch extends $cd61f496984300fe$var$BattleTypedSearch {\n    constructor(){\n        super(...arguments);\n        this.sortRow = [\n            \"sortpokemon\",\n            \"\"\n        ];\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"pokemon\") return true;\n        const poke = getID(BattlePokedex, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"type\":\n                if (poke.types.every((t)=>t != value)) return false;\n                break;\n            case \"move\":\n                if (!canLearn(poke.id, value)) return false;\n                break;\n            case \"ability\":\n                if (!$cd61f496984300fe$var$hasAbility(poke, value)) return false;\n                break;\n            case \"egggroup\":\n                if (poke.eggGroups.every((t)=>t != value)) return false;\n                break;\n        }\n        return true;\n    }\n    getTable() {\n        return BattlePokedex;\n    }\n    getDefaultResults() {\n        const groups = {};\n        for(const id in BattlePokedex){\n            const p = BattlePokedex[id];\n            if (!p) continue;\n            const baseId = toID(p.baseSpecies || p.name);\n            if (!groups[baseId]) groups[baseId] = {\n                base: id,\n                num: p.num || 0,\n                forms: []\n            };\n            // Identify base (prefer the entry whose name equals baseSpecies or has no forme)\n            const isBase = !p.forme || p.name === p.baseSpecies;\n            if (isBase) {\n                groups[baseId].base = id;\n                groups[baseId].num = p.num || groups[baseId].num;\n            } else groups[baseId].forms.push(id);\n        }\n        // Sort forms within each group deterministically (by name/forme)\n        for(const baseId in groups)groups[baseId].forms.sort((a, b)=>{\n            const pa = BattlePokedex[a];\n            const pb = BattlePokedex[b];\n            const fa = (pa.forme || pa.name).toLowerCase();\n            const fb = (pb.forme || pb.name).toLowerCase();\n            return fa < fb ? -1 : fa > fb ? 1 : 0;\n        });\n        // Order groups by dex number then base id\n        const ordered = Object.values(groups).sort((a, b)=>a.num - b.num || (a.base < b.base ? -1 : a.base > b.base ? 1 : 0));\n        // Build global form order mapping for suffix rendering in UI\n        window.BattleFormOrder = {};\n        for (const g of ordered)window.BattleFormOrder[toID(BattlePokedex[g.base].baseSpecies || BattlePokedex[g.base].name)] = g.forms.slice();\n        const results = [];\n        for (const g of ordered){\n            const baseId = g.base;\n            switch(baseId){\n                case \"bulbasaur\":\n                    results.push([\n                        \"header\",\n                        \"Generation 1\"\n                    ]);\n                    break;\n                case \"chikorita\":\n                    results.push([\n                        \"header\",\n                        \"Generation 2\"\n                    ]);\n                    break;\n                case \"treecko\":\n                    results.push([\n                        \"header\",\n                        \"Generation 3\"\n                    ]);\n                    break;\n                case \"turtwig\":\n                    results.push([\n                        \"header\",\n                        \"Generation 4\"\n                    ]);\n                    break;\n                case \"victini\":\n                    results.push([\n                        \"header\",\n                        \"Generation 5\"\n                    ]);\n                    break;\n                case \"chespin\":\n                    results.push([\n                        \"header\",\n                        \"Generation 6\"\n                    ]);\n                    break;\n                case \"rowlet\":\n                    results.push([\n                        \"header\",\n                        \"Generation 7\"\n                    ]);\n                    break;\n                case \"grookey\":\n                    results.push([\n                        \"header\",\n                        \"Generation 8\"\n                    ]);\n                    break;\n                case \"sprigatito\":\n                    results.push([\n                        \"header\",\n                        \"Generation 9\"\n                    ]);\n                    break;\n                case \"missingno\":\n                    results.push([\n                        \"header\",\n                        \"Glitch\"\n                    ]);\n                    break;\n                case \"syclar\":\n                    results.push([\n                        \"header\",\n                        \"CAP\"\n                    ]);\n                    break;\n                case \"pikachucosplay\":\n                    continue; // skip cosplay aggregate\n            }\n            results.push([\n                \"pokemon\",\n                baseId\n            ]);\n            for (const fid of g.forms)results.push([\n                \"pokemon\",\n                fid\n            ]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        if ([\n            \"hp\",\n            \"atk\",\n            \"def\",\n            \"spa\",\n            \"spd\",\n            \"spe\"\n        ].includes(sortCol)) return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const stat1 = getID(BattlePokedex, id1).baseStats[sortCol];\n            const stat2 = getID(BattlePokedex, id2).baseStats[sortCol];\n            return (stat2 - stat1) * sortOrder;\n        });\n        else if (sortCol === \"bst\") return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const base1 = getID(BattlePokedex, id1).baseStats;\n            const base2 = getID(BattlePokedex, id2).baseStats;\n            const bst1 = base1.hp + base1.atk + base1.def + base1.spa + base1.spd + base1.spe;\n            const bst2 = base2.hp + base2.atk + base2.def + base2.spa + base2.spd + base2.spe;\n            return (bst2 - bst1) * sortOrder;\n        });\n        else if (sortCol === \"name\") return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const name1 = id1;\n            const name2 = id2;\n            return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n        });\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $cd61f496984300fe$var$BattleAbilitySearch extends $cd61f496984300fe$var$BattleTypedSearch {\n    getTable() {\n        return BattleAbilities;\n    }\n    getDefaultResults() {\n        const results = [];\n        for(let id in BattleAbilities)results.push([\n            \"ability\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"ability\") return true;\n        const ability = getID(BattleAbilities, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"pokemon\":\n                if (!$cd61f496984300fe$var$hasAbility(getID(BattlePokedex, value), ability.name)) return false;\n                break;\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $cd61f496984300fe$var$BattleItemSearch extends $cd61f496984300fe$var$BattleTypedSearch {\n    getTable() {\n        return BattleItems;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\n            \"header\",\n            \"Items\"\n        ]);\n        for(let id in BattleItems)results.push([\n            \"item\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $cd61f496984300fe$var$BattleMoveSearch extends $cd61f496984300fe$var$BattleTypedSearch {\n    constructor(){\n        super(...arguments);\n        this.sortRow = [\n            \"sortmove\",\n            \"\"\n        ];\n    }\n    getTable() {\n        return BattleMovedex;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\n            \"header\",\n            \"Moves\"\n        ]);\n        for(let id in BattleMovedex)results.push([\n            \"move\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"move\") return true;\n        const move = getID(BattleMovedex, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"type\":\n                if (move.type !== value) return false;\n                break;\n            case \"category\":\n                if (move.category !== value) return false;\n                break;\n            case \"pokemon\":\n                if (!canLearn(value, move.id)) return false;\n                break;\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        switch(sortCol){\n            case \"power\":\n                let powerTable = {\n                    return: 102,\n                    frustration: 102,\n                    spitup: 300,\n                    trumpcard: 200,\n                    naturalgift: 80,\n                    grassknot: 120,\n                    lowkick: 120,\n                    gyroball: 150,\n                    electroball: 150,\n                    flail: 200,\n                    reversal: 200,\n                    present: 120,\n                    wringout: 120,\n                    crushgrip: 120,\n                    heatcrash: 120,\n                    heavyslam: 120,\n                    fling: 130,\n                    magnitude: 150,\n                    beatup: 24,\n                    punishment: 1020,\n                    psywave: 1250,\n                    nightshade: 1200,\n                    seismictoss: 1200,\n                    dragonrage: 1140,\n                    sonicboom: 1120,\n                    superfang: 1350,\n                    endeavor: 1399,\n                    sheercold: 1501,\n                    fissure: 1500,\n                    horndrill: 1500,\n                    guillotine: 1500\n                };\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let move1 = getID(BattleMovedex, id1);\n                    let move2 = getID(BattleMovedex, id2);\n                    let pow1 = move1.basePower || powerTable[id1] || (move1.category === \"Status\" ? -1 : 1400);\n                    let pow2 = move2.basePower || powerTable[id2] || (move2.category === \"Status\" ? -1 : 1400);\n                    return (pow2 - pow1) * sortOrder;\n                });\n            case \"accuracy\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let accuracy1 = getID(BattleMovedex, id1).accuracy || 0;\n                    let accuracy2 = getID(BattleMovedex, id2).accuracy || 0;\n                    if (accuracy1 === true) accuracy1 = 101;\n                    if (accuracy2 === true) accuracy2 = 101;\n                    return (accuracy2 - accuracy1) * sortOrder;\n                });\n            case \"pp\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let pp1 = getID(BattleMovedex, id1).pp || 0;\n                    let pp2 = getID(BattleMovedex, id2).pp || 0;\n                    return (pp2 - pp1) * sortOrder;\n                });\n            case \"name\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    const name1 = id1;\n                    const name2 = id2;\n                    return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n                });\n        }\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $cd61f496984300fe$var$BattleCategorySearch extends $cd61f496984300fe$var$BattleTypedSearch {\n    getTable() {\n        return {\n            physical: 1,\n            special: 1,\n            status: 1\n        };\n    }\n    getDefaultResults() {\n        return [\n            [\n                \"category\",\n                \"physical\"\n            ],\n            [\n                \"category\",\n                \"special\"\n            ],\n            [\n                \"category\",\n                \"status\"\n            ]\n        ];\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $cd61f496984300fe$var$BattleTypeSearch extends $cd61f496984300fe$var$BattleTypedSearch {\n    getTable() {\n        return BattleTypeChart;\n    }\n    getDefaultResults() {\n        const results = [];\n        for(let id in BattleTypeChart)results.push([\n            \"type\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nwindow.DexSearch = $cd61f496984300fe$var$DexSearch;\n\n\n//# sourceMappingURL=Binary-Star-Pokedex.0a9c728f.js.map\n","/**\n * Search\n *\n * Code for searching for dex information\n *\n *\n * @author Guangcong Luo <guangcongluo@gmail.com>\n * @license MIT\n */\n/** ID, SearchType, index (if alias), offset (if offset alias) */\nlet BattleSearchIndex = [];\nlet BattleSearchIndexOffset;\nfunction hasAbility(pokemon, ability) {\n    for (let key in pokemon.abilities) {\n        if (toID(pokemon.abilities[key]) == toID(ability)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction generateSearchIndex() {\n    let index = [];\n    index = index.concat(Object.keys(BattlePokedex).map((x) => x + \" pokemon\"));\n    index = index.concat(Object.keys(BattleMovedex).map((x) => x + \" move\"));\n    index = index.concat(Object.keys(BattleItems).map((x) => x + \" item\"));\n    index = index.concat(Object.keys(BattleAbilities).map((x) => x + \" ability\"));\n    index = index.concat(Object.keys(BattleTypeChart).map((x) => toID(x) + \" type\"));\n    index = index.concat([\"physical\", \"special\", \"status\"].map((x) => toID(x) + \" category\"));\n    index = index.concat([\n        \"monster\",\n        \"water1\",\n        \"bug\",\n        \"flying\",\n        \"field\",\n        \"fairy\",\n        \"grass\",\n        \"humanlike\",\n        \"water3\",\n        \"mineral\",\n        \"amorphous\",\n        \"water2\",\n        \"ditto\",\n        \"dragon\",\n        \"undiscovered\",\n    ].map((x) => toID(x) + \" egggroup\"));\n    index.sort();\n    // manually rearrange\n    index[index.indexOf(\"grass type\")] = \"grass egggroup\";\n    index[index.indexOf(\"grass egggroup\")] = \"grass type\";\n    index[index.indexOf(\"fairy type\")] = \"fairy egggroup\";\n    index[index.indexOf(\"fairy egggroup\")] = \"fairy type\";\n    index[index.indexOf(\"flying type\")] = \"flying egggroup\";\n    index[index.indexOf(\"flying egggroup\")] = \"flying type\";\n    index[index.indexOf(\"dragon type\")] = \"dragon egggroup\";\n    index[index.indexOf(\"dragon egggroup\")] = \"dragon type\";\n    index[index.indexOf(\"bug type\")] = \"bug egggroup\";\n    index[index.indexOf(\"bug egggroup\")] = \"bug type\";\n    index[index.indexOf(\"psychic type\")] = \"psychic move\";\n    index[index.indexOf(\"psychic move\")] = \"psychic type\";\n    if (getID(BattlePokedex, \"ditto\")) {\n        index[index.indexOf(\"ditto pokemon\")] = \"ditto egggroup\";\n        index[index.indexOf(\"ditto egggroup\")] = \"ditto pokemon\";\n    }\n    BattleSearchIndex = index.map((x) => {\n        let split = x.split(\" \");\n        if (split.length > 3) {\n            split[3] = Number(split[3]);\n            split[2] = index.indexOf(split[2] + \" \" + split[1]);\n        }\n        return split;\n    });\n    BattleSearchIndexOffset = BattleSearchIndex.map((entry, i) => {\n        var _a, _b, _c, _d;\n        const id = entry[0];\n        let name = \"\";\n        switch (entry[1]) {\n            case \"pokemon\":\n                name = (_a = getID(BattlePokedex, id).name) !== null && _a !== void 0 ? _a : \"\";\n                break;\n            case \"move\":\n                name = (_b = getID(BattleMovedex, id).name) !== null && _b !== void 0 ? _b : \"\";\n                break;\n            case \"item\":\n                name = (_c = getID(BattleItems, id).name) !== null && _c !== void 0 ? _c : \"\";\n                break;\n            case \"ability\":\n                name = (_d = getID(BattleAbilities, id).name) !== null && _d !== void 0 ? _d : \"\";\n                break;\n        }\n        let res = \"\";\n        let nonAlnum = 0;\n        for (let i = 0, j = 0; i < id.length; i++, j++) {\n            while (!/[a-zA-Z0-9]/.test(name[j])) {\n                j++;\n                nonAlnum++;\n            }\n            res += nonAlnum;\n        }\n        if (nonAlnum)\n            return res;\n        return \"\";\n    });\n}\n/**\n * Backend for search UIs.\n */\nclass DexSearch {\n    constructor(searchType = \"\", formatid = \"\", species = \"\") {\n        this.query = \"\";\n        this.typedSearch = null;\n        this.results = null;\n        this.exactMatch = false;\n        this.firstPokemonColumn = \"Number\";\n        /**\n         * Column to sort by. Default is `null`, a smart sort determined by how good\n         * things are according to the base filters, falling back to dex number (for\n         * Pokemon) and name (for everything else).\n         */\n        this.sortCol = null;\n        this.reverseSort = false;\n        /**\n         * Filters for the search result. Does not include the two base filters\n         * (format and species).\n         */\n        this.filters = null;\n        generateSearchIndex();\n        this.setType(searchType, formatid, species);\n    }\n    getTypedSearch(searchType, format = \"\", speciesOrSet) {\n        if (!searchType)\n            return null;\n        switch (searchType) {\n            case \"pokemon\":\n                return new BattlePokemonSearch(\"pokemon\", format, speciesOrSet);\n            case \"item\":\n                return new BattleItemSearch(\"item\", format, speciesOrSet);\n            case \"move\":\n                return new BattleMoveSearch(\"move\", format, speciesOrSet);\n            case \"ability\":\n                return new BattleAbilitySearch(\"ability\", format, speciesOrSet);\n            case \"type\":\n                return new BattleTypeSearch(\"type\", format, speciesOrSet);\n            case \"category\":\n                return new BattleCategorySearch(\"category\", format, speciesOrSet);\n        }\n        return null;\n    }\n    find(query) {\n        var _a;\n        query = toID(query);\n        if (this.query === query && this.results) {\n            return false;\n        }\n        this.query = query;\n        if (!query) {\n            this.results =\n                ((_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.getResults(this.filters, this.sortCol, this.reverseSort)) || [];\n        }\n        else {\n            this.results = this.textSearch(query);\n        }\n        return true;\n    }\n    setType(searchType, format = \"\", speciesOrSet) {\n        var _a;\n        // invalidate caches\n        this.results = null;\n        if (searchType !== ((_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.searchType)) {\n            this.filters = null;\n            this.sortCol = null;\n        }\n        this.typedSearch = this.getTypedSearch(searchType, format, speciesOrSet);\n    }\n    addFilter(entry) {\n        if (!this.typedSearch)\n            return false;\n        let [type] = entry;\n        if (this.typedSearch.searchType === \"pokemon\") {\n            if (type === this.sortCol)\n                this.sortCol = null;\n            if (![\"type\", \"move\", \"ability\", \"egggroup\", \"tier\"].includes(type))\n                return false;\n            if (type === \"move\")\n                entry[1] = toID(entry[1]);\n            if (!this.filters)\n                this.filters = [];\n            this.results = null;\n            for (const filter of this.filters) {\n                if (filter[0] === type && filter[1] === entry[1]) {\n                    return true;\n                }\n            }\n            this.filters.push(entry);\n            return true;\n        }\n        else if (this.typedSearch.searchType === \"move\") {\n            if (type === this.sortCol)\n                this.sortCol = null;\n            if (![\"type\", \"category\", \"pokemon\"].includes(type))\n                return false;\n            if (type === \"pokemon\")\n                entry[1] = toID(entry[1]);\n            if (!this.filters)\n                this.filters = [];\n            this.filters.push(entry);\n            this.results = null;\n            return true;\n        }\n        return false;\n    }\n    removeFilter(entry) {\n        if (!this.filters)\n            return false;\n        if (entry) {\n            const filterid = entry.join(\":\");\n            let deleted = null;\n            // delete specific filter\n            for (let i = 0; i < this.filters.length; i++) {\n                if (filterid === this.filters[i].join(\":\")) {\n                    deleted = this.filters[i];\n                    this.filters.splice(i, 1);\n                    break;\n                }\n            }\n            if (!deleted)\n                return false;\n        }\n        else {\n            this.filters.pop();\n        }\n        if (!this.filters.length)\n            this.filters = null;\n        this.results = null;\n        return true;\n    }\n    toggleSort(sortCol) {\n        if (this.sortCol === sortCol) {\n            if (!this.reverseSort) {\n                this.reverseSort = true;\n            }\n            else {\n                this.sortCol = null;\n                this.reverseSort = false;\n            }\n        }\n        else {\n            this.sortCol = sortCol;\n            this.reverseSort = false;\n        }\n        this.results = null;\n    }\n    filterLabel(filterType) {\n        if (this.typedSearch && this.typedSearch.searchType !== filterType) {\n            return \"Filter\";\n        }\n        return null;\n    }\n    illegalLabel(id) {\n        var _a, _b;\n        return ((_b = (_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.illegalReasons) === null || _b === void 0 ? void 0 : _b[id]) || null;\n    }\n    textSearch(query) {\n        var _a, _b, _c;\n        query = toID(query);\n        this.exactMatch = false;\n        let searchType = ((_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.searchType) || \"\";\n        // If searchType exists, we're searching mainly for results of that type.\n        // We'll still search for results of other types, but those results\n        // will only be used to filter results for that type.\n        let searchTypeIndex = searchType ? DexSearch.typeTable[searchType] : -1;\n        /** searching for \"Psychic type\" will make the type come up over the move */\n        let qFilterType = \"\";\n        if (query.slice(-4) === \"type\") {\n            if (query.slice(0, -4) in BattleTypeChart) {\n                query = query.slice(0, -4);\n                qFilterType = \"type\";\n            }\n        }\n        // i represents the location of the search index we're looking at\n        let i = DexSearch.getClosest(query);\n        this.exactMatch = BattleSearchIndex[i][0] === query;\n        // Even with output buffer buckets, we make multiple passes through\n        // the search index. searchPasses is a queue of which pass we're on:\n        // [passType, i, query]\n        // By doing an alias pass after the normal pass, we ensure that\n        // mid-word matches only display after start matches.\n        let passType = \"\";\n        let searchPasses = [[\"normal\", i, query]];\n        // For performance reasons, only do an alias pass if query is at\n        // least 2 chars long\n        if (query.length > 1)\n            searchPasses.push([\"alias\", i, query]);\n        // If there are no matches starting with query: Do a fuzzy match pass\n        // Fuzzy matches will still be shown after alias matches\n        if (!this.exactMatch &&\n            BattleSearchIndex[i][0].substr(0, query.length) !== query) {\n            // No results start with this. Do a fuzzy match pass.\n            let matchLength = query.length - 1;\n            if (!i)\n                i++;\n            while (matchLength &&\n                BattleSearchIndex[i][0].substr(0, matchLength) !==\n                    query.substr(0, matchLength) &&\n                BattleSearchIndex[i - 1][0].substr(0, matchLength) !==\n                    query.substr(0, matchLength)) {\n                matchLength--;\n            }\n            let matchQuery = query.substr(0, matchLength);\n            while (i >= 1 &&\n                BattleSearchIndex[i - 1][0].substr(0, matchLength) === matchQuery)\n                i--;\n            searchPasses.push([\"fuzzy\", i, \"\"]);\n        }\n        // We split the output buffers into 8 buckets.\n        // Bucket 0 is usually unused, and buckets 1-7 represent\n        // pokemon, types, moves, etc (see typeTable).\n        // When we're done, the buffers are concatenated together to form\n        // our results, with each buffer getting its own header, unlike\n        // multiple-pass results, which have no header.\n        // Notes:\n        // - if we have a searchType, that searchType's buffer will be on top\n        let bufs = [[], [], [], [], [], [], [], [], [], []];\n        let topbufIndex = -1;\n        let count = 0;\n        let nearMatch = false;\n        /** [type, id, typeIndex] */\n        let instafilter = null;\n        let instafilterSort = [0, 1, 2, 5, 4, 3, 6, 7, 8];\n        let illegal = (_b = this.typedSearch) === null || _b === void 0 ? void 0 : _b.illegalReasons;\n        // We aren't actually looping through the entirety of the searchIndex\n        for (i = 0; i < BattleSearchIndex.length; i++) {\n            if (!passType) {\n                let searchPass = searchPasses.shift();\n                if (!searchPass)\n                    break;\n                passType = searchPass[0];\n                i = searchPass[1];\n                query = searchPass[2];\n            }\n            let entry = BattleSearchIndex[i];\n            let id = entry[0];\n            let type = entry[1];\n            if (!id)\n                break;\n            if (passType === \"fuzzy\") {\n                // fuzzy match pass; stop after 2 results\n                if (count >= 2) {\n                    passType = \"\";\n                    continue;\n                }\n                nearMatch = true;\n            }\n            else if (passType === \"exact\") {\n                // exact pass; stop after 1 result\n                if (count >= 1) {\n                    passType = \"\";\n                    continue;\n                }\n            }\n            else if (id.substr(0, query.length) !== query) {\n                // regular pass, time to move onto our next match\n                passType = \"\";\n                continue;\n            }\n            if (entry.length > 2) {\n                // alias entry\n                if (passType !== \"alias\")\n                    continue;\n            }\n            else {\n                // normal entry\n                if (passType === \"alias\")\n                    continue;\n            }\n            let typeIndex = DexSearch.typeTable[type];\n            // For performance, with a query length of 1, we only fill the first bucket\n            if (query.length === 1 &&\n                typeIndex !== (searchType ? searchTypeIndex : 1))\n                continue;\n            // For pokemon queries, accept types/tier/abilities/moves/eggroups as filters\n            if (searchType === \"pokemon\" && (typeIndex === 5 || typeIndex > 7))\n                continue;\n            // For move queries, accept types/categories as filters\n            if (searchType === \"move\" &&\n                ((typeIndex !== 8 && typeIndex > 4) || typeIndex === 3))\n                continue;\n            // For move queries in the teambuilder, don't accept pokemon as filters\n            if (searchType === \"move\" && illegal && typeIndex === 1)\n                continue;\n            // For ability/item queries, don't accept anything else as a filter\n            if ((searchType === \"ability\" || searchType === \"item\") &&\n                typeIndex !== searchTypeIndex)\n                continue;\n            // Query was a type name followed 'type'; only show types\n            if (qFilterType === \"type\" && typeIndex !== 2)\n                continue;\n            // hardcode cases of duplicate non-consecutive aliases\n            if ((id === \"megax\" || id === \"megay\") && \"mega\".startsWith(query))\n                continue;\n            let matchStart = 0;\n            let matchEnd = 0;\n            if (passType === \"alias\") {\n                // alias entry\n                // [aliasid, type, originalid, matchStart, originalindex]\n                matchStart = entry[3];\n                let originalIndex = entry[2];\n                if (matchStart) {\n                    matchEnd = matchStart + query.length;\n                    matchStart +=\n                        (BattleSearchIndexOffset[originalIndex][matchStart] || \"0\").charCodeAt(0) - 48;\n                    matchEnd +=\n                        (BattleSearchIndexOffset[originalIndex][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n                }\n                id = BattleSearchIndex[originalIndex][0];\n            }\n            else {\n                matchEnd = query.length;\n                if (matchEnd)\n                    matchEnd +=\n                        (BattleSearchIndexOffset[i][matchEnd - 1] || \"0\").charCodeAt(0) -\n                            48;\n            }\n            if (searchType && searchTypeIndex !== typeIndex) {\n                // This is a filter, set it as an instafilter candidate\n                if (!instafilter ||\n                    instafilterSort[typeIndex] < instafilterSort[instafilter[2]]) {\n                    instafilter = [type, id, typeIndex];\n                }\n            }\n            // show types above Arceus formes\n            if (topbufIndex < 0 &&\n                searchTypeIndex < 2 &&\n                passType === \"alias\" &&\n                !bufs[1].length &&\n                bufs[2].length) {\n                topbufIndex = 2;\n            }\n            if (illegal && typeIndex === searchTypeIndex) {\n                // Always show illegal results under legal results.\n                // This is done by putting legal results (and the type header)\n                // in bucket 0, and illegal results in the searchType's bucket.\n                // searchType buckets are always on top (but under bucket 0), so\n                // illegal results will be seamlessly right under legal results.\n                if (!bufs[typeIndex].length && !bufs[0].length) {\n                    bufs[0] = [[\"header\", DexSearch.typeName[type]]];\n                }\n                if (!(id in illegal))\n                    typeIndex = 0;\n            }\n            else {\n                if (!bufs[typeIndex].length) {\n                    bufs[typeIndex] = [[\"header\", DexSearch.typeName[type]]];\n                }\n            }\n            // don't match duplicate aliases\n            let curBufLength = passType === \"alias\" && bufs[typeIndex].length;\n            if (curBufLength && bufs[typeIndex][curBufLength - 1][1] === id)\n                continue;\n            bufs[typeIndex].push([type, id, matchStart, matchEnd]);\n            count++;\n        }\n        let topbuf = [];\n        if (nearMatch) {\n            topbuf = [\n                [\n                    \"html\",\n                    `<em>No exact match found. The closest matches alphabetically are:</em>`,\n                ],\n            ];\n        }\n        if (topbufIndex >= 0) {\n            topbuf = topbuf.concat(bufs[topbufIndex]);\n            bufs[topbufIndex] = [];\n        }\n        if (searchTypeIndex >= 0) {\n            topbuf = topbuf.concat(bufs[0]);\n            topbuf = topbuf.concat(bufs[searchTypeIndex]);\n            bufs[searchTypeIndex] = [];\n            bufs[0] = [];\n        }\n        if (instafilter && count < 20) {\n            // Result count is less than 20, so we can instafilter\n            bufs.push(this.instafilter(searchType, instafilter[0], instafilter[1]));\n        }\n        this.results = Array.prototype.concat.apply(topbuf, bufs);\n        return (_c = this.results) !== null && _c !== void 0 ? _c : [];\n    }\n    instafilter(searchType, fType, fId) {\n        var _a;\n        let buf = [];\n        let illegalBuf = [];\n        let illegal = (_a = this.typedSearch) === null || _a === void 0 ? void 0 : _a.illegalReasons;\n        if (searchType === \"pokemon\") {\n            switch (fType) {\n                case \"type\":\n                    let type = (fId.charAt(0).toUpperCase() + fId.slice(1));\n                    buf.push([\"header\", `${type}-type Pok&eacute;mon`]);\n                    for (let id in BattlePokedex) {\n                        if (!BattlePokedex[id].types)\n                            continue;\n                        if (BattlePokedex[id].types.includes(type)) {\n                            (illegal && id in illegal ? illegalBuf : buf).push([\n                                \"pokemon\",\n                                id,\n                            ]);\n                        }\n                    }\n                    break;\n                case \"ability\":\n                    let ability = getID(BattleAbilities, fId).name;\n                    buf.push([\"header\", `${ability} Pok&eacute;mon`]);\n                    for (let id in BattlePokedex) {\n                        if (!BattlePokedex[id].abilities)\n                            continue;\n                        if (hasAbility(BattlePokedex[id], ability)) {\n                            (illegal && id in illegal ? illegalBuf : buf).push([\n                                \"pokemon\",\n                                id,\n                            ]);\n                        }\n                    }\n                    break;\n            }\n        }\n        else if (searchType === \"move\") {\n            switch (fType) {\n                case \"type\":\n                    let type = fId.charAt(0).toUpperCase() + fId.slice(1);\n                    buf.push([\"header\", `${type}-type moves`]);\n                    for (let id in BattleMovedex) {\n                        if (BattleMovedex[id].type === type) {\n                            (illegal && id in illegal ? illegalBuf : buf).push([\n                                \"move\",\n                                id,\n                            ]);\n                        }\n                    }\n                    break;\n                case \"category\":\n                    let category = fId.charAt(0).toUpperCase() + fId.slice(1);\n                    buf.push([\"header\", `${category} moves`]);\n                    for (let id in BattleMovedex) {\n                        if (BattleMovedex[id].category === category) {\n                            (illegal && id in illegal ? illegalBuf : buf).push([\n                                \"move\",\n                                id,\n                            ]);\n                        }\n                    }\n                    break;\n            }\n        }\n        return [...buf, ...illegalBuf];\n    }\n    static getClosest(query) {\n        // binary search through the index!\n        let left = 0;\n        let right = BattleSearchIndex.length - 1;\n        while (right > left) {\n            let mid = Math.floor((right - left) / 2 + left);\n            if (BattleSearchIndex[mid][0] === query &&\n                (mid === 0 || BattleSearchIndex[mid - 1][0] !== query)) {\n                // that's us\n                return mid;\n            }\n            else if (BattleSearchIndex[mid][0] < query) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        if (left >= BattleSearchIndex.length - 1)\n            left = BattleSearchIndex.length - 1;\n        else if (BattleSearchIndex[left + 1][0] &&\n            BattleSearchIndex[left][0] < query)\n            left++;\n        if (left && BattleSearchIndex[left - 1][0] === query)\n            left--;\n        return left;\n    }\n}\nDexSearch.typeTable = {\n    pokemon: 1,\n    type: 2,\n    tier: 3,\n    move: 4,\n    item: 5,\n    ability: 6,\n    egggroup: 7,\n    category: 8,\n    article: 9,\n};\nDexSearch.typeName = {\n    pokemon: \"Pok&eacute;mon\",\n    type: \"Type\",\n    tier: \"Tiers\",\n    move: \"Moves\",\n    item: \"Items\",\n    ability: \"Abilities\",\n    egggroup: \"Egg group\",\n    category: \"Category\",\n    article: \"Article\",\n};\nclass BattleTypedSearch {\n    constructor(searchType, format = \"\", speciesOrSet = \"\") {\n        /**\n         * `species` is the second of two base filters. It constrains results to\n         * things that species can use, and affects the default sort.\n         */\n        this.species = \"\";\n        /**\n         * `set` is a pseudo-base filter; it has minor effects on move sorting.\n         * (Abilities/items can affect what moves are sorted as usable.)\n         */\n        this.set = null;\n        /**\n         * Cached copy of what the results list would be with only base filters\n         * (i.e. with an empty `query` and `filters`)\n         */\n        this.baseResults = null;\n        /**\n         * Cached copy of all results not in `baseResults` - mostly in case a user\n         * is wondering why a specific result isn't showing up.\n         */\n        this.baseIllegalResults = null;\n        this.illegalReasons = null;\n        this.results = null;\n        this.sortRow = null;\n        this.searchType = searchType;\n        this.baseResults = null;\n        this.baseIllegalResults = null;\n        this.species = \"\";\n        this.set = null;\n        if (typeof speciesOrSet === \"string\") {\n            if (speciesOrSet)\n                this.species = speciesOrSet;\n        }\n        else {\n            this.set = speciesOrSet;\n            this.species = toID(this.set.species);\n        }\n        if (!searchType || !this.set)\n            return;\n    }\n    getResults(filters, sortCol, reverseSort) {\n        if (sortCol === \"type\") {\n            return [\n                this.sortRow,\n                ...BattleTypeSearch.prototype.getDefaultResults.call(this),\n            ];\n        }\n        else if (sortCol === \"category\") {\n            return [\n                this.sortRow,\n                ...BattleCategorySearch.prototype.getDefaultResults.call(this),\n            ];\n        }\n        else if (sortCol === \"ability\") {\n            return [\n                this.sortRow,\n                ...BattleAbilitySearch.prototype.getDefaultResults.call(this),\n            ];\n        }\n        if (!this.baseResults) {\n            this.baseResults = this.getBaseResults();\n        }\n        if (!this.baseIllegalResults) {\n            const legalityFilter = {};\n            for (const [resultType, value] of this.baseResults) {\n                if (resultType === this.searchType)\n                    legalityFilter[value] = 1;\n            }\n            this.baseIllegalResults = [];\n            this.illegalReasons = {};\n            for (const id in this.getTable()) {\n                if (!(id in legalityFilter)) {\n                    this.baseIllegalResults.push([this.searchType, id]);\n                    this.illegalReasons[id] = \"Illegal\";\n                }\n            }\n        }\n        let results;\n        let illegalResults;\n        if (filters) {\n            results = [];\n            illegalResults = [];\n            for (const result of this.baseResults) {\n                if (this.filter(result, filters)) {\n                    if (results.length &&\n                        result[0] === \"header\" &&\n                        results[results.length - 1][0] === \"header\") {\n                        results[results.length - 1] = result;\n                    }\n                    else {\n                        results.push(result);\n                    }\n                }\n            }\n            if (results.length && results[results.length - 1][0] === \"header\") {\n                results.pop();\n            }\n            for (const result of this.baseIllegalResults) {\n                if (this.filter(result, filters)) {\n                    illegalResults.push(result);\n                }\n            }\n        }\n        else {\n            results = [...this.baseResults];\n            illegalResults = null;\n        }\n        if (sortCol) {\n            results = results.filter(([rowType]) => rowType === this.searchType);\n            results = this.sort(results, sortCol, reverseSort);\n            if (illegalResults) {\n                illegalResults = illegalResults.filter(([rowType]) => rowType === this.searchType);\n                illegalResults = this.sort(illegalResults, sortCol, reverseSort);\n            }\n        }\n        if (this.sortRow) {\n            results = [this.sortRow, ...results];\n        }\n        if (illegalResults && illegalResults.length) {\n            results = [...results, [\"header\", \"Illegal results\"], ...illegalResults];\n        }\n        return results;\n    }\n}\nclass BattlePokemonSearch extends BattleTypedSearch {\n    constructor() {\n        super(...arguments);\n        this.sortRow = [\"sortpokemon\", \"\"];\n    }\n    filter(row, filters) {\n        if (!filters)\n            return true;\n        if (row[0] !== \"pokemon\")\n            return true;\n        const poke = getID(BattlePokedex, row[1]);\n        for (const [filterType, value] of filters) {\n            switch (filterType) {\n                case \"type\":\n                    if (poke.types.every((t) => t != value))\n                        return false;\n                    break;\n                case \"move\":\n                    if (!canLearn(poke.id, value))\n                        return false;\n                    break;\n                case \"ability\":\n                    if (!hasAbility(poke, value))\n                        return false;\n                    break;\n                case \"egggroup\":\n                    if (poke.eggGroups.every((t) => t != value))\n                        return false;\n                    break;\n            }\n        }\n        return true;\n    }\n    getTable() {\n        return BattlePokedex;\n    }\n    getDefaultResults() {\n        const groups = {};\n        for (const id in BattlePokedex) {\n            const p = BattlePokedex[id];\n            if (!p)\n                continue;\n            const baseId = toID(p.baseSpecies || p.name);\n            if (!groups[baseId]) {\n                groups[baseId] = { base: id, num: p.num || 0, forms: [] };\n            }\n            // Identify base (prefer the entry whose name equals baseSpecies or has no forme)\n            const isBase = !p.forme || p.name === p.baseSpecies;\n            if (isBase) {\n                groups[baseId].base = id;\n                groups[baseId].num = p.num || groups[baseId].num;\n            }\n            else {\n                groups[baseId].forms.push(id);\n            }\n        }\n        // Sort forms within each group deterministically (by name/forme)\n        for (const baseId in groups) {\n            groups[baseId].forms.sort((a, b) => {\n                const pa = BattlePokedex[a];\n                const pb = BattlePokedex[b];\n                const fa = (pa.forme || pa.name).toLowerCase();\n                const fb = (pb.forme || pb.name).toLowerCase();\n                return fa < fb ? -1 : fa > fb ? 1 : 0;\n            });\n        }\n        // Order groups by dex number then base id\n        const ordered = Object.values(groups).sort((a, b) => a.num - b.num || (a.base < b.base ? -1 : a.base > b.base ? 1 : 0));\n        // Build global form order mapping for suffix rendering in UI\n        window.BattleFormOrder = {};\n        for (const g of ordered) {\n            window.BattleFormOrder[toID(BattlePokedex[g.base].baseSpecies || BattlePokedex[g.base].name)] = g.forms.slice();\n        }\n        const results = [];\n        for (const g of ordered) {\n            const baseId = g.base;\n            switch (baseId) {\n                case \"bulbasaur\":\n                    results.push([\"header\", \"Generation 1\"]);\n                    break;\n                case \"chikorita\":\n                    results.push([\"header\", \"Generation 2\"]);\n                    break;\n                case \"treecko\":\n                    results.push([\"header\", \"Generation 3\"]);\n                    break;\n                case \"turtwig\":\n                    results.push([\"header\", \"Generation 4\"]);\n                    break;\n                case \"victini\":\n                    results.push([\"header\", \"Generation 5\"]);\n                    break;\n                case \"chespin\":\n                    results.push([\"header\", \"Generation 6\"]);\n                    break;\n                case \"rowlet\":\n                    results.push([\"header\", \"Generation 7\"]);\n                    break;\n                case \"grookey\":\n                    results.push([\"header\", \"Generation 8\"]);\n                    break;\n                case \"sprigatito\":\n                    results.push([\"header\", \"Generation 9\"]);\n                    break;\n                case \"missingno\":\n                    results.push([\"header\", \"Glitch\"]);\n                    break;\n                case \"syclar\":\n                    results.push([\"header\", \"CAP\"]);\n                    break;\n                case \"pikachucosplay\":\n                    continue; // skip cosplay aggregate\n            }\n            results.push([\"pokemon\", baseId]);\n            for (const fid of g.forms) {\n                results.push([\"pokemon\", fid]);\n            }\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        if ([\"hp\", \"atk\", \"def\", \"spa\", \"spd\", \"spe\"].includes(sortCol)) {\n            return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                const stat1 = getID(BattlePokedex, id1).baseStats[sortCol];\n                const stat2 = getID(BattlePokedex, id2).baseStats[sortCol];\n                return (stat2 - stat1) * sortOrder;\n            });\n        }\n        else if (sortCol === \"bst\") {\n            return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                const base1 = getID(BattlePokedex, id1).baseStats;\n                const base2 = getID(BattlePokedex, id2).baseStats;\n                const bst1 = base1.hp + base1.atk + base1.def + base1.spa + base1.spd + base1.spe;\n                const bst2 = base2.hp + base2.atk + base2.def + base2.spa + base2.spd + base2.spe;\n                return (bst2 - bst1) * sortOrder;\n            });\n        }\n        else if (sortCol === \"name\") {\n            return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                const name1 = id1;\n                const name2 = id2;\n                return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n            });\n        }\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass BattleAbilitySearch extends BattleTypedSearch {\n    getTable() {\n        return BattleAbilities;\n    }\n    getDefaultResults() {\n        const results = [];\n        for (let id in BattleAbilities) {\n            results.push([\"ability\", id]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters)\n            return true;\n        if (row[0] !== \"ability\")\n            return true;\n        const ability = getID(BattleAbilities, row[1]);\n        for (const [filterType, value] of filters) {\n            switch (filterType) {\n                case \"pokemon\":\n                    if (!hasAbility(getID(BattlePokedex, value), ability.name))\n                        return false;\n                    break;\n            }\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass BattleItemSearch extends BattleTypedSearch {\n    getTable() {\n        return BattleItems;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\"header\", \"Items\"]);\n        for (let id in BattleItems) {\n            results.push([\"item\", id]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass BattleMoveSearch extends BattleTypedSearch {\n    constructor() {\n        super(...arguments);\n        this.sortRow = [\"sortmove\", \"\"];\n    }\n    getTable() {\n        return BattleMovedex;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\"header\", \"Moves\"]);\n        for (let id in BattleMovedex) {\n            results.push([\"move\", id]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters)\n            return true;\n        if (row[0] !== \"move\")\n            return true;\n        const move = getID(BattleMovedex, row[1]);\n        for (const [filterType, value] of filters) {\n            switch (filterType) {\n                case \"type\":\n                    if (move.type !== value)\n                        return false;\n                    break;\n                case \"category\":\n                    if (move.category !== value)\n                        return false;\n                    break;\n                case \"pokemon\":\n                    if (!canLearn(value, move.id))\n                        return false;\n                    break;\n            }\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        switch (sortCol) {\n            case \"power\":\n                let powerTable = {\n                    return: 102,\n                    frustration: 102,\n                    spitup: 300,\n                    trumpcard: 200,\n                    naturalgift: 80,\n                    grassknot: 120,\n                    lowkick: 120,\n                    gyroball: 150,\n                    electroball: 150,\n                    flail: 200,\n                    reversal: 200,\n                    present: 120,\n                    wringout: 120,\n                    crushgrip: 120,\n                    heatcrash: 120,\n                    heavyslam: 120,\n                    fling: 130,\n                    magnitude: 150,\n                    beatup: 24,\n                    punishment: 1020,\n                    psywave: 1250,\n                    nightshade: 1200,\n                    seismictoss: 1200,\n                    dragonrage: 1140,\n                    sonicboom: 1120,\n                    superfang: 1350,\n                    endeavor: 1399,\n                    sheercold: 1501,\n                    fissure: 1500,\n                    horndrill: 1500,\n                    guillotine: 1500,\n                };\n                return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                    let move1 = getID(BattleMovedex, id1);\n                    let move2 = getID(BattleMovedex, id2);\n                    let pow1 = move1.basePower ||\n                        powerTable[id1] ||\n                        (move1.category === \"Status\" ? -1 : 1400);\n                    let pow2 = move2.basePower ||\n                        powerTable[id2] ||\n                        (move2.category === \"Status\" ? -1 : 1400);\n                    return (pow2 - pow1) * sortOrder;\n                });\n            case \"accuracy\":\n                return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                    let accuracy1 = getID(BattleMovedex, id1).accuracy || 0;\n                    let accuracy2 = getID(BattleMovedex, id2).accuracy || 0;\n                    if (accuracy1 === true)\n                        accuracy1 = 101;\n                    if (accuracy2 === true)\n                        accuracy2 = 101;\n                    return (accuracy2 - accuracy1) * sortOrder;\n                });\n            case \"pp\":\n                return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                    let pp1 = getID(BattleMovedex, id1).pp || 0;\n                    let pp2 = getID(BattleMovedex, id2).pp || 0;\n                    return (pp2 - pp1) * sortOrder;\n                });\n            case \"name\":\n                return results.sort(([rowType1, id1], [rowType2, id2]) => {\n                    const name1 = id1;\n                    const name2 = id2;\n                    return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n                });\n        }\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass BattleCategorySearch extends BattleTypedSearch {\n    getTable() {\n        return { physical: 1, special: 1, status: 1 };\n    }\n    getDefaultResults() {\n        return [\n            [\"category\", \"physical\"],\n            [\"category\", \"special\"],\n            [\"category\", \"status\"],\n        ];\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass BattleTypeSearch extends BattleTypedSearch {\n    getTable() {\n        return BattleTypeChart;\n    }\n    getDefaultResults() {\n        const results = [];\n        for (let id in BattleTypeChart) {\n            results.push([\"type\", id]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nwindow.DexSearch = DexSearch;\nexport {};\n"],"names":["$cd61f496984300fe$var$BattleSearchIndexOffset","$cd61f496984300fe$var$BattleSearchIndex","$cd61f496984300fe$var$hasAbility","pokemon","ability","key","abilities","toID","$cd61f496984300fe$var$DexSearch","searchType","formatid","species","index","query","typedSearch","results","exactMatch","firstPokemonColumn","sortCol","reverseSort","filters","concat","Object","keys","BattlePokedex","map","x","BattleMovedex","BattleItems","BattleAbilities","BattleTypeChart","sort","indexOf","getID","split","length","Number","entry","i","_a","_b","_c","_d","id","name","res","nonAlnum","j","test","setType","getTypedSearch","format","speciesOrSet","$cd61f496984300fe$var$BattlePokemonSearch","$cd61f496984300fe$var$BattleItemSearch","$cd61f496984300fe$var$BattleMoveSearch","$cd61f496984300fe$var$BattleAbilitySearch","$cd61f496984300fe$var$BattleTypeSearch","$cd61f496984300fe$var$BattleCategorySearch","find","textSearch","getResults","addFilter","type","includes","filter","push","removeFilter","filterid","join","deleted","splice","pop","toggleSort","filterLabel","filterType","illegalLabel","illegalReasons","searchTypeIndex","typeTable","qFilterType","slice","getClosest","passType","searchPasses","substr","matchLength","matchQuery","bufs","topbufIndex","count","nearMatch","instafilter","instafilterSort","illegal","searchPass","shift","typeIndex","startsWith","matchStart","matchEnd","originalIndex","charCodeAt","typeName","curBufLength","topbuf","Array","prototype","apply","fType","fId","buf","illegalBuf","charAt","toUpperCase","types","type1","category","left","right","mid","Math","floor","tier","move","item","egggroup","article","$cd61f496984300fe$var$BattleTypedSearch","set","baseResults","baseIllegalResults","sortRow","illegalResults","getDefaultResults","call","getBaseResults","legalityFilter","resultType","value","getTable","result","rowType","arguments","row","poke","every","t","canLearn","eggGroups","groups","p","baseId","baseSpecies","base","num","forms","forme","a","b","pa","pb","fa","toLowerCase","fb","ordered","values","g","window","BattleFormOrder","fid","sortOrder","rowType1","id1","rowType2","id2","stat1","baseStats","stat2","base1","base2","bst1","hp","atk","def","spa","spd","spe","bst2","name1","Error","powerTable","return","frustration","spitup","trumpcard","naturalgift","grassknot","lowkick","gyroball","electroball","flail","reversal","present","wringout","crushgrip","heatcrash","heavyslam","fling","magnitude","beatup","punishment","psywave","nightshade","seismictoss","dragonrage","sonicboom","superfang","endeavor","sheercold","fissure","horndrill","guillotine","move1","move2","pow1","basePower","pow2","accuracy1","accuracy","accuracy2","pp1","pp","pp2","physical","special","status","DexSearch"],"version":3,"file":"Binary-Star-Pokedex.0a9c728f.js.map"}