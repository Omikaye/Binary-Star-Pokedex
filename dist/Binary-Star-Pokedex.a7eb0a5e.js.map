{"mappings":"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","sources":["<anon>","ts/battle-dex-search.ts"],"sourcesContent":["/**\r\n * Search\r\n *\r\n * Code for searching for dex information\r\n *\r\n *\r\n * @author Guangcong Luo <guangcongluo@gmail.com>\r\n * @license MIT\r\n */ /** ID, SearchType, index (if alias), offset (if offset alias) */ let $978dcbb073010154$var$BattleSearchIndex = [];\nlet $978dcbb073010154$var$BattleSearchIndexOffset;\nfunction $978dcbb073010154$var$hasAbility(pokemon, ability) {\n    for(let key in pokemon.abilities){\n        if (toID(pokemon.abilities[key]) == toID(ability)) return true;\n    }\n    return false;\n}\nfunction $978dcbb073010154$var$generateSearchIndex() {\n    let index = [];\n    index = index.concat(Object.keys(BattlePokedex).map((x)=>x + \" pokemon\"));\n    index = index.concat(Object.keys(BattleMovedex).map((x)=>x + \" move\"));\n    index = index.concat(Object.keys(BattleItems).map((x)=>x + \" item\"));\n    index = index.concat(Object.keys(BattleAbilities).map((x)=>x + \" ability\"));\n    index = index.concat(Object.keys(BattleTypeChart).map((x)=>toID(x) + \" type\"));\n    index = index.concat([\n        \"physical\",\n        \"special\",\n        \"status\"\n    ].map((x)=>toID(x) + \" category\"));\n    index = index.concat([\n        \"monster\",\n        \"water1\",\n        \"bug\",\n        \"flying\",\n        \"field\",\n        \"fairy\",\n        \"grass\",\n        \"humanlike\",\n        \"water3\",\n        \"mineral\",\n        \"amorphous\",\n        \"water2\",\n        \"ditto\",\n        \"dragon\",\n        \"undiscovered\"\n    ].map((x)=>toID(x) + \" egggroup\"));\n    index.sort();\n    // manually rearrange\n    index[index.indexOf(\"grass type\")] = \"grass egggroup\";\n    index[index.indexOf(\"grass egggroup\")] = \"grass type\";\n    index[index.indexOf(\"fairy type\")] = \"fairy egggroup\";\n    index[index.indexOf(\"fairy egggroup\")] = \"fairy type\";\n    index[index.indexOf(\"flying type\")] = \"flying egggroup\";\n    index[index.indexOf(\"flying egggroup\")] = \"flying type\";\n    index[index.indexOf(\"dragon type\")] = \"dragon egggroup\";\n    index[index.indexOf(\"dragon egggroup\")] = \"dragon type\";\n    index[index.indexOf(\"bug type\")] = \"bug egggroup\";\n    index[index.indexOf(\"bug egggroup\")] = \"bug type\";\n    index[index.indexOf(\"psychic type\")] = \"psychic move\";\n    index[index.indexOf(\"psychic move\")] = \"psychic type\";\n    if (getID(BattlePokedex, \"ditto\")) {\n        index[index.indexOf(\"ditto pokemon\")] = \"ditto egggroup\";\n        index[index.indexOf(\"ditto egggroup\")] = \"ditto pokemon\";\n    }\n    $978dcbb073010154$var$BattleSearchIndex = index.map((x)=>{\n        let split = x.split(\" \");\n        if (split.length > 3) {\n            split[3] = Number(split[3]);\n            split[2] = index.indexOf(split[2] + \" \" + split[1]);\n        }\n        return split;\n    });\n    $978dcbb073010154$var$BattleSearchIndexOffset = $978dcbb073010154$var$BattleSearchIndex.map((entry, i)=>{\n        const id = entry[0];\n        let name = \"\";\n        switch(entry[1]){\n            case \"pokemon\":\n                name = getID(BattlePokedex, id).name ?? \"\";\n                break;\n            case \"move\":\n                name = getID(BattleMovedex, id).name ?? \"\";\n                break;\n            case \"item\":\n                name = getID(BattleItems, id).name ?? \"\";\n                break;\n            case \"ability\":\n                name = getID(BattleAbilities, id).name ?? \"\";\n                break;\n        }\n        let res = \"\";\n        let nonAlnum = 0;\n        for(let i = 0, j = 0; i < id.length; i++, j++){\n            while(!/[a-zA-Z0-9]/.test(name[j])){\n                j++;\n                nonAlnum++;\n            }\n            res += nonAlnum;\n        }\n        if (nonAlnum) return res;\n        return \"\";\n    });\n}\n/**\r\n\r\n/**\r\n * Backend for search UIs.\r\n */ class $978dcbb073010154$var$DexSearch {\n    static{\n        this.typeTable = {\n            pokemon: 1,\n            type: 2,\n            tier: 3,\n            move: 4,\n            item: 5,\n            ability: 6,\n            egggroup: 7,\n            category: 8,\n            article: 9\n        };\n    }\n    static{\n        this.typeName = {\n            pokemon: \"Pok&eacute;mon\",\n            type: \"Type\",\n            tier: \"Tiers\",\n            move: \"Moves\",\n            item: \"Items\",\n            ability: \"Abilities\",\n            egggroup: \"Egg group\",\n            category: \"Category\",\n            article: \"Article\"\n        };\n    }\n    constructor(searchType = \"\", formatid = \"\", species = \"\"){\n        this.query = \"\";\n        this.typedSearch = null;\n        this.results = null;\n        this.exactMatch = false;\n        this.firstPokemonColumn = \"Number\";\n        /**\r\n   * Column to sort by. Default is `null`, a smart sort determined by how good\r\n   * things are according to the base filters, falling back to dex number (for\r\n   * Pokemon) and name (for everything else).\r\n   */ this.sortCol = null;\n        this.reverseSort = false;\n        /**\r\n   * Filters for the search result. Does not include the two base filters\r\n   * (format and species).\r\n   */ this.filters = null;\n        $978dcbb073010154$var$generateSearchIndex();\n        this.setType(searchType, formatid, species);\n    }\n    getTypedSearch(searchType, format = \"\", speciesOrSet) {\n        if (!searchType) return null;\n        switch(searchType){\n            case \"pokemon\":\n                return new $978dcbb073010154$var$BattlePokemonSearch(\"pokemon\", format, speciesOrSet);\n            case \"item\":\n                return new $978dcbb073010154$var$BattleItemSearch(\"item\", format, speciesOrSet);\n            case \"move\":\n                return new $978dcbb073010154$var$BattleMoveSearch(\"move\", format, speciesOrSet);\n            case \"ability\":\n                return new $978dcbb073010154$var$BattleAbilitySearch(\"ability\", format, speciesOrSet);\n            case \"type\":\n                return new $978dcbb073010154$var$BattleTypeSearch(\"type\", format, speciesOrSet);\n            case \"category\":\n                return new $978dcbb073010154$var$BattleCategorySearch(\"category\", format, speciesOrSet);\n        }\n        return null;\n    }\n    find(query) {\n        query = toID(query);\n        if (this.query === query && this.results) return false;\n        this.query = query;\n        if (!query) this.results = this.typedSearch?.getResults(this.filters, this.sortCol, this.reverseSort) || [];\n        else this.results = this.textSearch(query);\n        return true;\n    }\n    setType(searchType, format = \"\", speciesOrSet) {\n        // invalidate caches\n        this.results = null;\n        if (searchType !== this.typedSearch?.searchType) {\n            this.filters = null;\n            this.sortCol = null;\n        }\n        this.typedSearch = this.getTypedSearch(searchType, format, speciesOrSet);\n    }\n    addFilter(entry) {\n        if (!this.typedSearch) return false;\n        let [type] = entry;\n        if (this.typedSearch.searchType === \"pokemon\") {\n            if (type === this.sortCol) this.sortCol = null;\n            if (![\n                \"type\",\n                \"move\",\n                \"ability\",\n                \"egggroup\",\n                \"tier\"\n            ].includes(type)) return false;\n            if (type === \"move\") entry[1] = toID(entry[1]);\n            if (!this.filters) this.filters = [];\n            this.results = null;\n            for (const filter of this.filters){\n                if (filter[0] === type && filter[1] === entry[1]) return true;\n            }\n            this.filters.push(entry);\n            return true;\n        } else if (this.typedSearch.searchType === \"move\") {\n            if (type === this.sortCol) this.sortCol = null;\n            if (![\n                \"type\",\n                \"category\",\n                \"pokemon\"\n            ].includes(type)) return false;\n            if (type === \"pokemon\") entry[1] = toID(entry[1]);\n            if (!this.filters) this.filters = [];\n            this.filters.push(entry);\n            this.results = null;\n            return true;\n        }\n        return false;\n    }\n    removeFilter(entry) {\n        if (!this.filters) return false;\n        if (entry) {\n            const filterid = entry.join(\":\");\n            let deleted = null;\n            // delete specific filter\n            for(let i = 0; i < this.filters.length; i++)if (filterid === this.filters[i].join(\":\")) {\n                deleted = this.filters[i];\n                this.filters.splice(i, 1);\n                break;\n            }\n            if (!deleted) return false;\n        } else this.filters.pop();\n        if (!this.filters.length) this.filters = null;\n        this.results = null;\n        return true;\n    }\n    toggleSort(sortCol) {\n        if (this.sortCol === sortCol) {\n            if (!this.reverseSort) this.reverseSort = true;\n            else {\n                this.sortCol = null;\n                this.reverseSort = false;\n            }\n        } else {\n            this.sortCol = sortCol;\n            this.reverseSort = false;\n        }\n        this.results = null;\n    }\n    filterLabel(filterType) {\n        if (this.typedSearch && this.typedSearch.searchType !== filterType) return \"Filter\";\n        return null;\n    }\n    illegalLabel(id) {\n        return this.typedSearch?.illegalReasons?.[id] || null;\n    }\n    textSearch(query) {\n        query = toID(query);\n        this.exactMatch = false;\n        let searchType = this.typedSearch?.searchType || \"\";\n        // If searchType exists, we're searching mainly for results of that type.\n        // We'll still search for results of other types, but those results\n        // will only be used to filter results for that type.\n        let searchTypeIndex = searchType ? $978dcbb073010154$var$DexSearch.typeTable[searchType] : -1;\n        /** searching for \"Psychic type\" will make the type come up over the move */ let qFilterType = \"\";\n        if (query.slice(-4) === \"type\") {\n            if (query.slice(0, -4) in BattleTypeChart) {\n                query = query.slice(0, -4);\n                qFilterType = \"type\";\n            }\n        }\n        // i represents the location of the search index we're looking at\n        let i = $978dcbb073010154$var$DexSearch.getClosest(query);\n        this.exactMatch = $978dcbb073010154$var$BattleSearchIndex[i][0] === query;\n        // Even with output buffer buckets, we make multiple passes through\n        // the search index. searchPasses is a queue of which pass we're on:\n        // [passType, i, query]\n        // By doing an alias pass after the normal pass, we ensure that\n        // mid-word matches only display after start matches.\n        let passType = \"\";\n        let searchPasses = [\n            [\n                \"normal\",\n                i,\n                query\n            ]\n        ];\n        // For performance reasons, only do an alias pass if query is at\n        // least 2 chars long\n        if (query.length > 1) searchPasses.push([\n            \"alias\",\n            i,\n            query\n        ]);\n        // If there are no matches starting with query: Do a fuzzy match pass\n        // Fuzzy matches will still be shown after alias matches\n        if (!this.exactMatch && $978dcbb073010154$var$BattleSearchIndex[i][0].substr(0, query.length) !== query) {\n            // No results start with this. Do a fuzzy match pass.\n            let matchLength = query.length - 1;\n            if (!i) i++;\n            while(matchLength && $978dcbb073010154$var$BattleSearchIndex[i][0].substr(0, matchLength) !== query.substr(0, matchLength) && $978dcbb073010154$var$BattleSearchIndex[i - 1][0].substr(0, matchLength) !== query.substr(0, matchLength))matchLength--;\n            let matchQuery = query.substr(0, matchLength);\n            while(i >= 1 && $978dcbb073010154$var$BattleSearchIndex[i - 1][0].substr(0, matchLength) === matchQuery)i--;\n            searchPasses.push([\n                \"fuzzy\",\n                i,\n                \"\"\n            ]);\n        }\n        // We split the output buffers into 8 buckets.\n        // Bucket 0 is usually unused, and buckets 1-7 represent\n        // pokemon, types, moves, etc (see typeTable).\n        // When we're done, the buffers are concatenated together to form\n        // our results, with each buffer getting its own header, unlike\n        // multiple-pass results, which have no header.\n        // Notes:\n        // - if we have a searchType, that searchType's buffer will be on top\n        let bufs = [\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            [],\n            []\n        ];\n        let topbufIndex = -1;\n        let count = 0;\n        let nearMatch = false;\n        /** [type, id, typeIndex] */ let instafilter = null;\n        let instafilterSort = [\n            0,\n            1,\n            2,\n            5,\n            4,\n            3,\n            6,\n            7,\n            8\n        ];\n        let illegal = this.typedSearch?.illegalReasons;\n        // We aren't actually looping through the entirety of the searchIndex\n        for(i = 0; i < $978dcbb073010154$var$BattleSearchIndex.length; i++){\n            if (!passType) {\n                let searchPass = searchPasses.shift();\n                if (!searchPass) break;\n                passType = searchPass[0];\n                i = searchPass[1];\n                query = searchPass[2];\n            }\n            let entry = $978dcbb073010154$var$BattleSearchIndex[i];\n            let id = entry[0];\n            let type = entry[1];\n            if (!id) break;\n            if (passType === \"fuzzy\") {\n                // fuzzy match pass; stop after 2 results\n                if (count >= 2) {\n                    passType = \"\";\n                    continue;\n                }\n                nearMatch = true;\n            } else if (passType === \"exact\") // exact pass; stop after 1 result\n            {\n                if (count >= 1) {\n                    passType = \"\";\n                    continue;\n                }\n            } else if (id.substr(0, query.length) !== query) {\n                // regular pass, time to move onto our next match\n                passType = \"\";\n                continue;\n            }\n            if (entry.length > 2) {\n                // alias entry\n                if (passType !== \"alias\") continue;\n            } else {\n                // normal entry\n                if (passType === \"alias\") continue;\n            }\n            let typeIndex = $978dcbb073010154$var$DexSearch.typeTable[type];\n            // For performance, with a query length of 1, we only fill the first bucket\n            if (query.length === 1 && typeIndex !== (searchType ? searchTypeIndex : 1)) continue;\n            // For pokemon queries, accept types/tier/abilities/moves/eggroups as filters\n            if (searchType === \"pokemon\" && (typeIndex === 5 || typeIndex > 7)) continue;\n            // For move queries, accept types/categories as filters\n            if (searchType === \"move\" && (typeIndex !== 8 && typeIndex > 4 || typeIndex === 3)) continue;\n            // For move queries in the teambuilder, don't accept pokemon as filters\n            if (searchType === \"move\" && illegal && typeIndex === 1) continue;\n            // For ability/item queries, don't accept anything else as a filter\n            if ((searchType === \"ability\" || searchType === \"item\") && typeIndex !== searchTypeIndex) continue;\n            // Query was a type name followed 'type'; only show types\n            if (qFilterType === \"type\" && typeIndex !== 2) continue;\n            // hardcode cases of duplicate non-consecutive aliases\n            if ((id === \"megax\" || id === \"megay\") && \"mega\".startsWith(query)) continue;\n            let matchStart = 0;\n            let matchEnd = 0;\n            if (passType === \"alias\") {\n                // alias entry\n                // [aliasid, type, originalid, matchStart, originalindex]\n                matchStart = entry[3];\n                let originalIndex = entry[2];\n                if (matchStart) {\n                    matchEnd = matchStart + query.length;\n                    matchStart += ($978dcbb073010154$var$BattleSearchIndexOffset[originalIndex][matchStart] || \"0\").charCodeAt(0) - 48;\n                    matchEnd += ($978dcbb073010154$var$BattleSearchIndexOffset[originalIndex][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n                }\n                id = $978dcbb073010154$var$BattleSearchIndex[originalIndex][0];\n            } else {\n                matchEnd = query.length;\n                if (matchEnd) matchEnd += ($978dcbb073010154$var$BattleSearchIndexOffset[i][matchEnd - 1] || \"0\").charCodeAt(0) - 48;\n            }\n            if (searchType && searchTypeIndex !== typeIndex) // This is a filter, set it as an instafilter candidate\n            {\n                if (!instafilter || instafilterSort[typeIndex] < instafilterSort[instafilter[2]]) instafilter = [\n                    type,\n                    id,\n                    typeIndex\n                ];\n            }\n            // show types above Arceus formes\n            if (topbufIndex < 0 && searchTypeIndex < 2 && passType === \"alias\" && !bufs[1].length && bufs[2].length) topbufIndex = 2;\n            if (illegal && typeIndex === searchTypeIndex) {\n                // Always show illegal results under legal results.\n                // This is done by putting legal results (and the type header)\n                // in bucket 0, and illegal results in the searchType's bucket.\n                // searchType buckets are always on top (but under bucket 0), so\n                // illegal results will be seamlessly right under legal results.\n                if (!bufs[typeIndex].length && !bufs[0].length) bufs[0] = [\n                    [\n                        \"header\",\n                        $978dcbb073010154$var$DexSearch.typeName[type]\n                    ]\n                ];\n                if (!(id in illegal)) typeIndex = 0;\n            } else if (!bufs[typeIndex].length) bufs[typeIndex] = [\n                [\n                    \"header\",\n                    $978dcbb073010154$var$DexSearch.typeName[type]\n                ]\n            ];\n            // don't match duplicate aliases\n            let curBufLength = passType === \"alias\" && bufs[typeIndex].length;\n            if (curBufLength && bufs[typeIndex][curBufLength - 1][1] === id) continue;\n            bufs[typeIndex].push([\n                type,\n                id,\n                matchStart,\n                matchEnd\n            ]);\n            count++;\n        }\n        let topbuf = [];\n        if (nearMatch) topbuf = [\n            [\n                \"html\",\n                `<em>No exact match found. The closest matches alphabetically are:</em>`\n            ]\n        ];\n        if (topbufIndex >= 0) {\n            topbuf = topbuf.concat(bufs[topbufIndex]);\n            bufs[topbufIndex] = [];\n        }\n        if (searchTypeIndex >= 0) {\n            topbuf = topbuf.concat(bufs[0]);\n            topbuf = topbuf.concat(bufs[searchTypeIndex]);\n            bufs[searchTypeIndex] = [];\n            bufs[0] = [];\n        }\n        if (instafilter && count < 20) // Result count is less than 20, so we can instafilter\n        bufs.push(this.instafilter(searchType, instafilter[0], instafilter[1]));\n        this.results = Array.prototype.concat.apply(topbuf, bufs);\n        return this.results ?? [];\n    }\n    instafilter(searchType, fType, fId) {\n        let buf = [];\n        let illegalBuf = [];\n        let illegal = this.typedSearch?.illegalReasons;\n        if (searchType === \"pokemon\") switch(fType){\n            case \"type\":\n                let type = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${type}-type Pok&eacute;mon`\n                ]);\n                for(let id in BattlePokedex){\n                    if (!BattlePokedex[id].types) continue;\n                    if (BattlePokedex[id].types.includes(type)) (illegal && id in illegal ? illegalBuf : buf).push([\n                        \"pokemon\",\n                        id\n                    ]);\n                }\n                break;\n            case \"ability\":\n                let ability = getID(BattleAbilities, fId).name;\n                buf.push([\n                    \"header\",\n                    `${ability} Pok&eacute;mon`\n                ]);\n                for(let id in BattlePokedex){\n                    if (!BattlePokedex[id].abilities) continue;\n                    if ($978dcbb073010154$var$hasAbility(BattlePokedex[id], ability)) (illegal && id in illegal ? illegalBuf : buf).push([\n                        \"pokemon\",\n                        id\n                    ]);\n                }\n                break;\n        }\n        else if (searchType === \"move\") switch(fType){\n            case \"type\":\n                let type1 = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${type1}-type moves`\n                ]);\n                for(let id in BattleMovedex)if (BattleMovedex[id].type === type1) (illegal && id in illegal ? illegalBuf : buf).push([\n                    \"move\",\n                    id\n                ]);\n                break;\n            case \"category\":\n                let category = fId.charAt(0).toUpperCase() + fId.slice(1);\n                buf.push([\n                    \"header\",\n                    `${category} moves`\n                ]);\n                for(let id in BattleMovedex)if (BattleMovedex[id].category === category) (illegal && id in illegal ? illegalBuf : buf).push([\n                    \"move\",\n                    id\n                ]);\n                break;\n        }\n        return [\n            ...buf,\n            ...illegalBuf\n        ];\n    }\n    static getClosest(query) {\n        // binary search through the index!\n        let left = 0;\n        let right = $978dcbb073010154$var$BattleSearchIndex.length - 1;\n        while(right > left){\n            let mid = Math.floor((right - left) / 2 + left);\n            if ($978dcbb073010154$var$BattleSearchIndex[mid][0] === query && (mid === 0 || $978dcbb073010154$var$BattleSearchIndex[mid - 1][0] !== query)) // that's us\n            return mid;\n            else if ($978dcbb073010154$var$BattleSearchIndex[mid][0] < query) left = mid + 1;\n            else right = mid - 1;\n        }\n        if (left >= $978dcbb073010154$var$BattleSearchIndex.length - 1) left = $978dcbb073010154$var$BattleSearchIndex.length - 1;\n        else if ($978dcbb073010154$var$BattleSearchIndex[left + 1][0] && $978dcbb073010154$var$BattleSearchIndex[left][0] < query) left++;\n        if (left && $978dcbb073010154$var$BattleSearchIndex[left - 1][0] === query) left--;\n        return left;\n    }\n}\nclass $978dcbb073010154$var$BattleTypedSearch {\n    constructor(searchType, format = \"\", speciesOrSet = \"\"){\n        /**\r\n   * `species` is the second of two base filters. It constrains results to\r\n   * things that species can use, and affects the default sort.\r\n   */ this.species = \"\";\n        /**\r\n   * `set` is a pseudo-base filter; it has minor effects on move sorting.\r\n   * (Abilities/items can affect what moves are sorted as usable.)\r\n   */ this.set = null;\n        /**\r\n   * Cached copy of what the results list would be with only base filters\r\n   * (i.e. with an empty `query` and `filters`)\r\n   */ this.baseResults = null;\n        /**\r\n   * Cached copy of all results not in `baseResults` - mostly in case a user\r\n   * is wondering why a specific result isn't showing up.\r\n   */ this.baseIllegalResults = null;\n        this.illegalReasons = null;\n        this.results = null;\n        this.sortRow = null;\n        this.searchType = searchType;\n        this.baseResults = null;\n        this.baseIllegalResults = null;\n        this.species = \"\";\n        this.set = null;\n        if (typeof speciesOrSet === \"string\") {\n            if (speciesOrSet) this.species = speciesOrSet;\n        } else {\n            this.set = speciesOrSet;\n            this.species = toID(this.set.species);\n        }\n        if (!searchType || !this.set) return;\n    }\n    getResults(filters, sortCol, reverseSort) {\n        if (sortCol === \"type\") return [\n            this.sortRow,\n            ...$978dcbb073010154$var$BattleTypeSearch.prototype.getDefaultResults.call(this)\n        ];\n        else if (sortCol === \"category\") return [\n            this.sortRow,\n            ...$978dcbb073010154$var$BattleCategorySearch.prototype.getDefaultResults.call(this)\n        ];\n        else if (sortCol === \"ability\") return [\n            this.sortRow,\n            ...$978dcbb073010154$var$BattleAbilitySearch.prototype.getDefaultResults.call(this)\n        ];\n        if (!this.baseResults) this.baseResults = this.getBaseResults();\n        if (!this.baseIllegalResults) {\n            const legalityFilter = {};\n            for (const [resultType, value] of this.baseResults)if (resultType === this.searchType) legalityFilter[value] = 1;\n            this.baseIllegalResults = [];\n            this.illegalReasons = {};\n            for(const id in this.getTable())if (!(id in legalityFilter)) {\n                this.baseIllegalResults.push([\n                    this.searchType,\n                    id\n                ]);\n                this.illegalReasons[id] = \"Illegal\";\n            }\n        }\n        let results;\n        let illegalResults;\n        if (filters) {\n            results = [];\n            illegalResults = [];\n            for (const result of this.baseResults)if (this.filter(result, filters)) {\n                if (results.length && result[0] === \"header\" && results[results.length - 1][0] === \"header\") results[results.length - 1] = result;\n                else results.push(result);\n            }\n            if (results.length && results[results.length - 1][0] === \"header\") results.pop();\n            for (const result of this.baseIllegalResults)if (this.filter(result, filters)) illegalResults.push(result);\n        } else {\n            results = [\n                ...this.baseResults\n            ];\n            illegalResults = null;\n        }\n        if (sortCol) {\n            results = results.filter(([rowType])=>rowType === this.searchType);\n            results = this.sort(results, sortCol, reverseSort);\n            if (illegalResults) {\n                illegalResults = illegalResults.filter(([rowType])=>rowType === this.searchType);\n                illegalResults = this.sort(illegalResults, sortCol, reverseSort);\n            }\n        }\n        if (this.sortRow) results = [\n            this.sortRow,\n            ...results\n        ];\n        if (illegalResults && illegalResults.length) results = [\n            ...results,\n            [\n                \"header\",\n                \"Illegal results\"\n            ],\n            ...illegalResults\n        ];\n        return results;\n    }\n}\nclass $978dcbb073010154$var$BattlePokemonSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"pokemon\") return true;\n        const poke = getID(BattlePokedex, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"type\":\n                if (poke.types.every((t)=>t != value)) return false;\n                break;\n            case \"move\":\n                if (!canLearn(poke.id, value)) return false;\n                break;\n            case \"ability\":\n                if (!$978dcbb073010154$var$hasAbility(poke, value)) return false;\n                break;\n            case \"egggroup\":\n                if (poke.eggGroups.every((t)=>t != value)) return false;\n                break;\n        }\n        return true;\n    }\n    getTable() {\n        return BattlePokedex;\n    }\n    getDefaultResults() {\n        const groups = {};\n        for(const id in BattlePokedex){\n            const p = BattlePokedex[id];\n            if (!p) continue;\n            const baseId = toID(p.baseSpecies || p.name);\n            if (!groups[baseId]) groups[baseId] = {\n                base: id,\n                num: p.num || 0,\n                forms: []\n            };\n            // Identify base (prefer the entry whose name equals baseSpecies or has no forme)\n            const isBase = !p.forme || p.name === p.baseSpecies;\n            if (isBase) {\n                groups[baseId].base = id;\n                groups[baseId].num = p.num || groups[baseId].num;\n            } else groups[baseId].forms.push(id);\n        }\n        // Sort forms within each group deterministically (by name/forme)\n        for(const baseId in groups)groups[baseId].forms.sort((a, b)=>{\n            const pa = BattlePokedex[a];\n            const pb = BattlePokedex[b];\n            const fa = (pa.forme || pa.name).toLowerCase();\n            const fb = (pb.forme || pb.name).toLowerCase();\n            return fa < fb ? -1 : fa > fb ? 1 : 0;\n        });\n        // Order groups by dex number then base id\n        const ordered = Object.values(groups).sort((a, b)=>a.num - b.num || (a.base < b.base ? -1 : a.base > b.base ? 1 : 0));\n        // Build global form order mapping for suffix rendering in UI\n        window.BattleFormOrder = {};\n        for (const g of ordered)window.BattleFormOrder[toID(BattlePokedex[g.base].baseSpecies || BattlePokedex[g.base].name)] = g.forms.slice();\n        const results = [];\n        for (const g of ordered){\n            const baseId = g.base;\n            switch(baseId){\n                case \"bulbasaur\":\n                    results.push([\n                        \"header\",\n                        \"Generation 1\"\n                    ]);\n                    break;\n                case \"chikorita\":\n                    results.push([\n                        \"header\",\n                        \"Generation 2\"\n                    ]);\n                    break;\n                case \"treecko\":\n                    results.push([\n                        \"header\",\n                        \"Generation 3\"\n                    ]);\n                    break;\n                case \"turtwig\":\n                    results.push([\n                        \"header\",\n                        \"Generation 4\"\n                    ]);\n                    break;\n                case \"victini\":\n                    results.push([\n                        \"header\",\n                        \"Generation 5\"\n                    ]);\n                    break;\n                case \"chespin\":\n                    results.push([\n                        \"header\",\n                        \"Generation 6\"\n                    ]);\n                    break;\n                case \"rowlet\":\n                    results.push([\n                        \"header\",\n                        \"Generation 7\"\n                    ]);\n                    break;\n                case \"grookey\":\n                    results.push([\n                        \"header\",\n                        \"Generation 8\"\n                    ]);\n                    break;\n                case \"sprigatito\":\n                    results.push([\n                        \"header\",\n                        \"Generation 9\"\n                    ]);\n                    break;\n                case \"missingno\":\n                    results.push([\n                        \"header\",\n                        \"Glitch\"\n                    ]);\n                    break;\n                case \"syclar\":\n                    results.push([\n                        \"header\",\n                        \"CAP\"\n                    ]);\n                    break;\n                case \"pikachucosplay\":\n                    continue; // skip cosplay aggregate\n            }\n            results.push([\n                \"pokemon\",\n                baseId\n            ]);\n            for (const fid of g.forms)results.push([\n                \"pokemon\",\n                fid\n            ]);\n        }\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        if ([\n            \"hp\",\n            \"atk\",\n            \"def\",\n            \"spa\",\n            \"spd\",\n            \"spe\"\n        ].includes(sortCol)) return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const stat1 = getID(BattlePokedex, id1).baseStats[sortCol];\n            const stat2 = getID(BattlePokedex, id2).baseStats[sortCol];\n            return (stat2 - stat1) * sortOrder;\n        });\n        else if (sortCol === \"bst\") return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const base1 = getID(BattlePokedex, id1).baseStats;\n            const base2 = getID(BattlePokedex, id2).baseStats;\n            const bst1 = base1.hp + base1.atk + base1.def + base1.spa + base1.spd + base1.spe;\n            const bst2 = base2.hp + base2.atk + base2.def + base2.spa + base2.spd + base2.spe;\n            return (bst2 - bst1) * sortOrder;\n        });\n        else if (sortCol === \"name\") return results.sort(([rowType1, id1], [rowType2, id2])=>{\n            const name1 = id1;\n            const name2 = id2;\n            return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n        });\n        throw new Error(\"invalid sortcol\");\n    }\n    constructor(...args){\n        super(...args), this.sortRow = [\n            \"sortpokemon\",\n            \"\"\n        ];\n    }\n}\nclass $978dcbb073010154$var$BattleAbilitySearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleAbilities;\n    }\n    getDefaultResults() {\n        const results = [];\n        for(let id in BattleAbilities)results.push([\n            \"ability\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"ability\") return true;\n        const ability = getID(BattleAbilities, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"pokemon\":\n                if (!$978dcbb073010154$var$hasAbility(getID(BattlePokedex, value), ability.name)) return false;\n                break;\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $978dcbb073010154$var$BattleItemSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleItems;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\n            \"header\",\n            \"Items\"\n        ]);\n        for(let id in BattleItems)results.push([\n            \"item\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $978dcbb073010154$var$BattleMoveSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleMovedex;\n    }\n    getDefaultResults() {\n        let results = [];\n        results.push([\n            \"header\",\n            \"Moves\"\n        ]);\n        for(let id in BattleMovedex)results.push([\n            \"move\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        if (!filters) return true;\n        if (row[0] !== \"move\") return true;\n        const move = getID(BattleMovedex, row[1]);\n        for (const [filterType, value] of filters)switch(filterType){\n            case \"type\":\n                if (move.type !== value) return false;\n                break;\n            case \"category\":\n                if (move.category !== value) return false;\n                break;\n            case \"pokemon\":\n                if (!canLearn(value, move.id)) return false;\n                break;\n        }\n        return true;\n    }\n    sort(results, sortCol, reverseSort) {\n        const sortOrder = reverseSort ? -1 : 1;\n        switch(sortCol){\n            case \"power\":\n                let powerTable = {\n                    return: 102,\n                    frustration: 102,\n                    spitup: 300,\n                    trumpcard: 200,\n                    naturalgift: 80,\n                    grassknot: 120,\n                    lowkick: 120,\n                    gyroball: 150,\n                    electroball: 150,\n                    flail: 200,\n                    reversal: 200,\n                    present: 120,\n                    wringout: 120,\n                    crushgrip: 120,\n                    heatcrash: 120,\n                    heavyslam: 120,\n                    fling: 130,\n                    magnitude: 150,\n                    beatup: 24,\n                    punishment: 1020,\n                    psywave: 1250,\n                    nightshade: 1200,\n                    seismictoss: 1200,\n                    dragonrage: 1140,\n                    sonicboom: 1120,\n                    superfang: 1350,\n                    endeavor: 1399,\n                    sheercold: 1501,\n                    fissure: 1500,\n                    horndrill: 1500,\n                    guillotine: 1500\n                };\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let move1 = getID(BattleMovedex, id1);\n                    let move2 = getID(BattleMovedex, id2);\n                    let pow1 = move1.basePower || powerTable[id1] || (move1.category === \"Status\" ? -1 : 1400);\n                    let pow2 = move2.basePower || powerTable[id2] || (move2.category === \"Status\" ? -1 : 1400);\n                    return (pow2 - pow1) * sortOrder;\n                });\n            case \"accuracy\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let accuracy1 = getID(BattleMovedex, id1).accuracy || 0;\n                    let accuracy2 = getID(BattleMovedex, id2).accuracy || 0;\n                    if (accuracy1 === true) accuracy1 = 101;\n                    if (accuracy2 === true) accuracy2 = 101;\n                    return (accuracy2 - accuracy1) * sortOrder;\n                });\n            case \"pp\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    let pp1 = getID(BattleMovedex, id1).pp || 0;\n                    let pp2 = getID(BattleMovedex, id2).pp || 0;\n                    return (pp2 - pp1) * sortOrder;\n                });\n            case \"name\":\n                return results.sort(([rowType1, id1], [rowType2, id2])=>{\n                    const name1 = id1;\n                    const name2 = id2;\n                    return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\n                });\n        }\n        throw new Error(\"invalid sortcol\");\n    }\n    constructor(...args){\n        super(...args), this.sortRow = [\n            \"sortmove\",\n            \"\"\n        ];\n    }\n}\nclass $978dcbb073010154$var$BattleCategorySearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return {\n            physical: 1,\n            special: 1,\n            status: 1\n        };\n    }\n    getDefaultResults() {\n        return [\n            [\n                \"category\",\n                \"physical\"\n            ],\n            [\n                \"category\",\n                \"special\"\n            ],\n            [\n                \"category\",\n                \"status\"\n            ]\n        ];\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nclass $978dcbb073010154$var$BattleTypeSearch extends $978dcbb073010154$var$BattleTypedSearch {\n    getTable() {\n        return BattleTypeChart;\n    }\n    getDefaultResults() {\n        const results = [];\n        for(let id in BattleTypeChart)results.push([\n            \"type\",\n            id\n        ]);\n        return results;\n    }\n    getBaseResults() {\n        return this.getDefaultResults();\n    }\n    filter(row, filters) {\n        throw new Error(\"invalid filter\");\n    }\n    sort(results, sortCol, reverseSort) {\n        throw new Error(\"invalid sortcol\");\n    }\n}\nwindow.DexSearch = $978dcbb073010154$var$DexSearch;\n\n\n//# sourceMappingURL=Binary-Star-Pokedex.a7eb0a5e.js.map\n","/**\r\n * Search\r\n *\r\n * Code for searching for dex information\r\n *\r\n *\r\n * @author Guangcong Luo <guangcongluo@gmail.com>\r\n * @license MIT\r\n */\r\n\r\ntype ID = string;\r\ntype TypeName = string;\r\n\r\ntype SearchType =\r\n  | \"pokemon\"\r\n  | \"type\"\r\n  | \"tier\"\r\n  | \"move\"\r\n  | \"item\"\r\n  | \"ability\"\r\n  | \"egggroup\"\r\n  | \"category\";\r\n\r\ntype SearchRow =\r\n  | [SearchType, ID, number?, number?]\r\n  | [\"sortpokemon\" | \"sortmove\", \"\"]\r\n  | [\"header\" | \"html\", string];\r\n\r\ntype SearchFilter = [string, string];\r\n\r\n/**\r\n * PokemonSet can be sparse, in which case that entry should be\r\n * inferred from the rest of the set, according to sensible\r\n * defaults.\r\n */\r\ninterface PokemonSet {\r\n  species: string;\r\n}\r\n\r\n/** ID, SearchType, index (if alias), offset (if offset alias) */\r\nlet BattleSearchIndex: [ID, SearchType, number?, number?][] = [];\r\nlet BattleSearchIndexOffset: any;\r\ndeclare const BattleMovedex: any;\r\ndeclare const BattleAbilities: any;\r\ndeclare const BattleTypeChart: any;\r\ndeclare const BattlePokedex: any;\r\ndeclare const BattleItems: any;\r\ndeclare const Learnsets: any;\r\n\r\ndeclare function toID(id: string): ID;\r\ndeclare function getID(set: any, text: string): any;\r\ndeclare function canLearn(poke: ID, move: ID): boolean;\r\n\r\nfunction hasAbility(pokemon: any, ability: ID) {\r\n  for (let key in pokemon.abilities) {\r\n    if (toID(pokemon.abilities[key]) == toID(ability)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction generateSearchIndex() {\r\n  let index: string[] = [];\r\n\r\n  index = index.concat(Object.keys(BattlePokedex).map((x) => x + \" pokemon\"));\r\n  index = index.concat(Object.keys(BattleMovedex).map((x) => x + \" move\"));\r\n  index = index.concat(Object.keys(BattleItems).map((x) => x + \" item\"));\r\n  index = index.concat(Object.keys(BattleAbilities).map((x) => x + \" ability\"));\r\n  index = index.concat(\r\n    Object.keys(BattleTypeChart).map((x) => toID(x) + \" type\")\r\n  );\r\n  index = index.concat(\r\n    [\"physical\", \"special\", \"status\"].map((x) => toID(x) + \" category\")\r\n  );\r\n  index = index.concat(\r\n    [\r\n      \"monster\",\r\n      \"water1\",\r\n      \"bug\",\r\n      \"flying\",\r\n      \"field\",\r\n      \"fairy\",\r\n      \"grass\",\r\n      \"humanlike\",\r\n      \"water3\",\r\n      \"mineral\",\r\n      \"amorphous\",\r\n      \"water2\",\r\n      \"ditto\",\r\n      \"dragon\",\r\n      \"undiscovered\",\r\n    ].map((x) => toID(x) + \" egggroup\")\r\n  );\r\n\r\n  index.sort();\r\n\r\n  // manually rearrange\r\n  index[index.indexOf(\"grass type\")] = \"grass egggroup\";\r\n  index[index.indexOf(\"grass egggroup\")] = \"grass type\";\r\n\r\n  index[index.indexOf(\"fairy type\")] = \"fairy egggroup\";\r\n  index[index.indexOf(\"fairy egggroup\")] = \"fairy type\";\r\n\r\n  index[index.indexOf(\"flying type\")] = \"flying egggroup\";\r\n  index[index.indexOf(\"flying egggroup\")] = \"flying type\";\r\n\r\n  index[index.indexOf(\"dragon type\")] = \"dragon egggroup\";\r\n  index[index.indexOf(\"dragon egggroup\")] = \"dragon type\";\r\n\r\n  index[index.indexOf(\"bug type\")] = \"bug egggroup\";\r\n  index[index.indexOf(\"bug egggroup\")] = \"bug type\";\r\n\r\n  index[index.indexOf(\"psychic type\")] = \"psychic move\";\r\n  index[index.indexOf(\"psychic move\")] = \"psychic type\";\r\n\r\n  if (getID(BattlePokedex, \"ditto\")) {\r\n    index[index.indexOf(\"ditto pokemon\")] = \"ditto egggroup\";\r\n    index[index.indexOf(\"ditto egggroup\")] = \"ditto pokemon\";\r\n  }\r\n\r\n  BattleSearchIndex = index.map((x) => {\r\n    let split: [ID, SearchType, number?, number?] = x.split(\" \") as any;\r\n    if (split.length > 3) {\r\n      split[3] = Number(split[3]);\r\n      split[2] = index.indexOf(split[2] + \" \" + split[1]);\r\n    }\r\n    return split;\r\n  });\r\n\r\n  BattleSearchIndexOffset = BattleSearchIndex.map((entry, i) => {\r\n    const id = entry[0];\r\n    let name = \"\";\r\n    switch (entry[1]) {\r\n      case \"pokemon\":\r\n        name = getID(BattlePokedex, id).name ?? \"\";\r\n        break;\r\n      case \"move\":\r\n        name = getID(BattleMovedex, id).name ?? \"\";\r\n        break;\r\n      case \"item\":\r\n        name = getID(BattleItems, id).name ?? \"\";\r\n        break;\r\n      case \"ability\":\r\n        name = getID(BattleAbilities, id).name ?? \"\";\r\n        break;\r\n    }\r\n    let res = \"\";\r\n    let nonAlnum = 0;\r\n    for (let i = 0, j = 0; i < id.length; i++, j++) {\r\n      while (!/[a-zA-Z0-9]/.test(name[j])) {\r\n        j++;\r\n        nonAlnum++;\r\n      }\r\n      res += nonAlnum;\r\n    }\r\n    if (nonAlnum) return res;\r\n    return \"\";\r\n  });\r\n}\r\n/**\r\n\r\n/**\r\n * Backend for search UIs.\r\n */\r\nclass DexSearch {\r\n  query = \"\";\r\n\r\n  typedSearch: BattleTypedSearch<SearchType> | null = null;\r\n\r\n  results: SearchRow[] | null = null;\r\n  exactMatch = false;\r\n\r\n  static typeTable = {\r\n    pokemon: 1,\r\n    type: 2,\r\n    tier: 3,\r\n    move: 4,\r\n    item: 5,\r\n    ability: 6,\r\n    egggroup: 7,\r\n    category: 8,\r\n    article: 9,\r\n  };\r\n  static typeName = {\r\n    pokemon: \"Pok&eacute;mon\",\r\n    type: \"Type\",\r\n    tier: \"Tiers\",\r\n    move: \"Moves\",\r\n    item: \"Items\",\r\n    ability: \"Abilities\",\r\n    egggroup: \"Egg group\",\r\n    category: \"Category\",\r\n    article: \"Article\",\r\n  };\r\n  firstPokemonColumn: \"Tier\" | \"Number\" = \"Number\";\r\n\r\n  /**\r\n   * Column to sort by. Default is `null`, a smart sort determined by how good\r\n   * things are according to the base filters, falling back to dex number (for\r\n   * Pokemon) and name (for everything else).\r\n   */\r\n  sortCol: string | null = null;\r\n  reverseSort = false;\r\n\r\n  /**\r\n   * Filters for the search result. Does not include the two base filters\r\n   * (format and species).\r\n   */\r\n  filters: SearchFilter[] | null = null;\r\n\r\n  constructor(\r\n    searchType: SearchType | \"\" = \"\",\r\n    formatid = \"\" as ID,\r\n    species = \"\" as ID\r\n  ) {\r\n\t\tgenerateSearchIndex();\r\n    this.setType(searchType, formatid, species);\r\n  }\r\n\r\n  getTypedSearch(\r\n    searchType: SearchType | \"\",\r\n    format = \"\" as ID,\r\n    speciesOrSet: ID\r\n  ) {\r\n    if (!searchType) return null;\r\n    switch (searchType) {\r\n      case \"pokemon\":\r\n        return new BattlePokemonSearch(\"pokemon\", format, speciesOrSet);\r\n      case \"item\":\r\n        return new BattleItemSearch(\"item\", format, speciesOrSet);\r\n      case \"move\":\r\n        return new BattleMoveSearch(\"move\", format, speciesOrSet);\r\n      case \"ability\":\r\n        return new BattleAbilitySearch(\"ability\", format, speciesOrSet);\r\n      case \"type\":\r\n        return new BattleTypeSearch(\"type\", format, speciesOrSet);\r\n      case \"category\":\r\n        return new BattleCategorySearch(\"category\", format, speciesOrSet);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  find(query: string) {\r\n    query = toID(query);\r\n    if (this.query === query && this.results) {\r\n      return false;\r\n    }\r\n    this.query = query;\r\n    if (!query) {\r\n      this.results =\r\n        this.typedSearch?.getResults(\r\n          this.filters,\r\n          this.sortCol,\r\n          this.reverseSort\r\n        ) || [];\r\n    } else {\r\n      this.results = this.textSearch(query);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  setType(searchType: SearchType | \"\", format = \"\" as ID, speciesOrSet: ID) {\r\n    // invalidate caches\r\n    this.results = null;\r\n\r\n    if (searchType !== this.typedSearch?.searchType) {\r\n      this.filters = null;\r\n      this.sortCol = null;\r\n    }\r\n    this.typedSearch = this.getTypedSearch(searchType, format, speciesOrSet);\r\n  }\r\n\r\n  addFilter(entry: SearchFilter): boolean {\r\n    if (!this.typedSearch) return false;\r\n    let [type] = entry;\r\n    if (this.typedSearch.searchType === \"pokemon\") {\r\n      if (type === this.sortCol) this.sortCol = null;\r\n      if (![\"type\", \"move\", \"ability\", \"egggroup\", \"tier\"].includes(type))\r\n        return false;\r\n      if (type === \"move\") entry[1] = toID(entry[1]);\r\n      if (!this.filters) this.filters = [];\r\n      this.results = null;\r\n      for (const filter of this.filters) {\r\n        if (filter[0] === type && filter[1] === entry[1]) {\r\n          return true;\r\n        }\r\n      }\r\n      this.filters.push(entry);\r\n      return true;\r\n    } else if (this.typedSearch.searchType === \"move\") {\r\n      if (type === this.sortCol) this.sortCol = null;\r\n      if (![\"type\", \"category\", \"pokemon\"].includes(type)) return false;\r\n      if (type === \"pokemon\") entry[1] = toID(entry[1]);\r\n      if (!this.filters) this.filters = [];\r\n      this.filters.push(entry);\r\n      this.results = null;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  removeFilter(entry?: SearchFilter): boolean {\r\n    if (!this.filters) return false;\r\n    if (entry) {\r\n      const filterid = entry.join(\":\");\r\n      let deleted: string[] | null = null;\r\n      // delete specific filter\r\n      for (let i = 0; i < this.filters.length; i++) {\r\n        if (filterid === this.filters[i].join(\":\")) {\r\n          deleted = this.filters[i];\r\n          this.filters.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n      if (!deleted) return false;\r\n    } else {\r\n      this.filters.pop();\r\n    }\r\n    if (!this.filters.length) this.filters = null;\r\n    this.results = null;\r\n    return true;\r\n  }\r\n\r\n  toggleSort(sortCol: string) {\r\n    if (this.sortCol === sortCol) {\r\n      if (!this.reverseSort) {\r\n        this.reverseSort = true;\r\n      } else {\r\n        this.sortCol = null;\r\n        this.reverseSort = false;\r\n      }\r\n    } else {\r\n      this.sortCol = sortCol;\r\n      this.reverseSort = false;\r\n    }\r\n    this.results = null;\r\n  }\r\n\r\n  filterLabel(filterType: string) {\r\n    if (this.typedSearch && this.typedSearch.searchType !== filterType) {\r\n      return \"Filter\";\r\n    }\r\n    return null;\r\n  }\r\n  illegalLabel(id: ID) {\r\n    return this.typedSearch?.illegalReasons?.[id] || null;\r\n  }\r\n\r\n  textSearch(query: string): SearchRow[] {\r\n    query = toID(query);\r\n\r\n    this.exactMatch = false;\r\n    let searchType: SearchType | \"\" = this.typedSearch?.searchType || \"\";\r\n\r\n    // If searchType exists, we're searching mainly for results of that type.\r\n    // We'll still search for results of other types, but those results\r\n    // will only be used to filter results for that type.\r\n    let searchTypeIndex = searchType ? DexSearch.typeTable[searchType] : -1;\r\n\r\n    /** searching for \"Psychic type\" will make the type come up over the move */\r\n    let qFilterType: \"type\" | \"\" = \"\";\r\n    if (query.slice(-4) === \"type\") {\r\n      if (query.slice(0, -4) in BattleTypeChart) {\r\n        query = query.slice(0, -4);\r\n        qFilterType = \"type\";\r\n      }\r\n    }\r\n\r\n    // i represents the location of the search index we're looking at\r\n    let i = DexSearch.getClosest(query);\r\n    this.exactMatch = BattleSearchIndex[i][0] === query;\r\n\r\n    // Even with output buffer buckets, we make multiple passes through\r\n    // the search index. searchPasses is a queue of which pass we're on:\r\n    // [passType, i, query]\r\n\r\n    // By doing an alias pass after the normal pass, we ensure that\r\n    // mid-word matches only display after start matches.\r\n    let passType: SearchPassType | \"\" = \"\";\r\n    /**\r\n     * pass types:\r\n     * * '': time to pop the next pass off the searchPasses queue\r\n     * * 'normal': start at i and stop when results no longer start with query\r\n     * * 'alias': like normal, but output aliases instead of non-alias results\r\n     * * 'fuzzy': start at i and stop when you have two results\r\n     * * 'exact': like normal, but stop at i\r\n     */\r\n    type SearchPassType = \"normal\" | \"alias\" | \"fuzzy\" | \"exact\";\r\n    /**\r\n     * [passType, i, query]\r\n     *\r\n     * i = index of BattleSearchIndex to start from\r\n     *\r\n     * By doing an alias pass after the normal pass, we ensure that\r\n     * mid-word matches only display after start matches.\r\n     */\r\n    type SearchPass = [SearchPassType, number, string];\r\n    let searchPasses: SearchPass[] = [[\"normal\", i, query]];\r\n\r\n    // For performance reasons, only do an alias pass if query is at\r\n    // least 2 chars long\r\n    if (query.length > 1) searchPasses.push([\"alias\", i, query]);\r\n\r\n    // If there are no matches starting with query: Do a fuzzy match pass\r\n    // Fuzzy matches will still be shown after alias matches\r\n    if (\r\n      !this.exactMatch &&\r\n      BattleSearchIndex[i][0].substr(0, query.length) !== query\r\n    ) {\r\n      // No results start with this. Do a fuzzy match pass.\r\n      let matchLength = query.length - 1;\r\n      if (!i) i++;\r\n      while (\r\n        matchLength &&\r\n        BattleSearchIndex[i][0].substr(0, matchLength) !==\r\n          query.substr(0, matchLength) &&\r\n        BattleSearchIndex[i - 1][0].substr(0, matchLength) !==\r\n          query.substr(0, matchLength)\r\n      ) {\r\n        matchLength--;\r\n      }\r\n      let matchQuery = query.substr(0, matchLength);\r\n      while (\r\n        i >= 1 &&\r\n        BattleSearchIndex[i - 1][0].substr(0, matchLength) === matchQuery\r\n      )\r\n        i--;\r\n      searchPasses.push([\"fuzzy\", i, \"\"]);\r\n    }\r\n\r\n    // We split the output buffers into 8 buckets.\r\n    // Bucket 0 is usually unused, and buckets 1-7 represent\r\n    // pokemon, types, moves, etc (see typeTable).\r\n\r\n    // When we're done, the buffers are concatenated together to form\r\n    // our results, with each buffer getting its own header, unlike\r\n    // multiple-pass results, which have no header.\r\n\r\n    // Notes:\r\n    // - if we have a searchType, that searchType's buffer will be on top\r\n    let bufs: SearchRow[][] = [[], [], [], [], [], [], [], [], [], []];\r\n    let topbufIndex = -1;\r\n\r\n    let count = 0;\r\n    let nearMatch = false;\r\n\r\n    /** [type, id, typeIndex] */\r\n    let instafilter: [SearchType, ID, number] | null = null;\r\n    let instafilterSort = [0, 1, 2, 5, 4, 3, 6, 7, 8];\r\n    let illegal = this.typedSearch?.illegalReasons;\r\n\r\n    // We aren't actually looping through the entirety of the searchIndex\r\n    for (i = 0; i < BattleSearchIndex.length; i++) {\r\n      if (!passType) {\r\n        let searchPass = searchPasses.shift();\r\n        if (!searchPass) break;\r\n        passType = searchPass[0];\r\n        i = searchPass[1];\r\n        query = searchPass[2];\r\n      }\r\n\r\n      let entry = BattleSearchIndex[i];\r\n      let id = entry[0];\r\n      let type = entry[1];\r\n\r\n      if (!id) break;\r\n\r\n      if (passType === \"fuzzy\") {\r\n        // fuzzy match pass; stop after 2 results\r\n        if (count >= 2) {\r\n          passType = \"\";\r\n          continue;\r\n        }\r\n        nearMatch = true;\r\n      } else if (passType === \"exact\") {\r\n        // exact pass; stop after 1 result\r\n        if (count >= 1) {\r\n          passType = \"\";\r\n          continue;\r\n        }\r\n      } else if (id.substr(0, query.length) !== query) {\r\n        // regular pass, time to move onto our next match\r\n        passType = \"\";\r\n        continue;\r\n      }\r\n\r\n      if (entry.length > 2) {\r\n        // alias entry\r\n        if (passType !== \"alias\") continue;\r\n      } else {\r\n        // normal entry\r\n        if (passType === \"alias\") continue;\r\n      }\r\n\r\n      let typeIndex = DexSearch.typeTable[type];\r\n\r\n      // For performance, with a query length of 1, we only fill the first bucket\r\n      if (\r\n        query.length === 1 &&\r\n        typeIndex !== (searchType ? searchTypeIndex : 1)\r\n      )\r\n        continue;\r\n\r\n      // For pokemon queries, accept types/tier/abilities/moves/eggroups as filters\r\n      if (searchType === \"pokemon\" && (typeIndex === 5 || typeIndex > 7))\r\n        continue;\r\n      // For move queries, accept types/categories as filters\r\n      if (\r\n        searchType === \"move\" &&\r\n        ((typeIndex !== 8 && typeIndex > 4) || typeIndex === 3)\r\n      )\r\n        continue;\r\n      // For move queries in the teambuilder, don't accept pokemon as filters\r\n      if (searchType === \"move\" && illegal && typeIndex === 1) continue;\r\n      // For ability/item queries, don't accept anything else as a filter\r\n      if (\r\n        (searchType === \"ability\" || searchType === \"item\") &&\r\n        typeIndex !== searchTypeIndex\r\n      )\r\n        continue;\r\n      // Query was a type name followed 'type'; only show types\r\n      if (qFilterType === \"type\" && typeIndex !== 2) continue;\r\n      // hardcode cases of duplicate non-consecutive aliases\r\n      if ((id === \"megax\" || id === \"megay\") && \"mega\".startsWith(query))\r\n        continue;\r\n\r\n      let matchStart = 0;\r\n      let matchEnd = 0;\r\n      if (passType === \"alias\") {\r\n        // alias entry\r\n        // [aliasid, type, originalid, matchStart, originalindex]\r\n        matchStart = entry[3]!;\r\n        let originalIndex = entry[2]!;\r\n        if (matchStart) {\r\n          matchEnd = matchStart + query.length;\r\n          matchStart +=\r\n            (\r\n              BattleSearchIndexOffset[originalIndex][matchStart] || \"0\"\r\n            ).charCodeAt(0) - 48;\r\n          matchEnd +=\r\n            (\r\n              BattleSearchIndexOffset[originalIndex][matchEnd - 1] || \"0\"\r\n            ).charCodeAt(0) - 48;\r\n        }\r\n        id = BattleSearchIndex[originalIndex][0];\r\n      } else {\r\n        matchEnd = query.length;\r\n        if (matchEnd)\r\n          matchEnd +=\r\n            (BattleSearchIndexOffset[i][matchEnd - 1] || \"0\").charCodeAt(0) -\r\n            48;\r\n      }\r\n\r\n      if (searchType && searchTypeIndex !== typeIndex) {\r\n        // This is a filter, set it as an instafilter candidate\r\n        if (\r\n          !instafilter ||\r\n          instafilterSort[typeIndex] < instafilterSort[instafilter[2]]\r\n        ) {\r\n          instafilter = [type, id, typeIndex];\r\n        }\r\n      }\r\n\r\n      // show types above Arceus formes\r\n      if (\r\n        topbufIndex < 0 &&\r\n        searchTypeIndex < 2 &&\r\n        passType === \"alias\" &&\r\n        !bufs[1].length &&\r\n        bufs[2].length\r\n      ) {\r\n        topbufIndex = 2;\r\n      }\r\n\r\n      if (illegal && typeIndex === searchTypeIndex) {\r\n        // Always show illegal results under legal results.\r\n        // This is done by putting legal results (and the type header)\r\n        // in bucket 0, and illegal results in the searchType's bucket.\r\n        // searchType buckets are always on top (but under bucket 0), so\r\n        // illegal results will be seamlessly right under legal results.\r\n        if (!bufs[typeIndex].length && !bufs[0].length) {\r\n          bufs[0] = [[\"header\", DexSearch.typeName[type]]];\r\n        }\r\n        if (!(id in illegal)) typeIndex = 0;\r\n      } else {\r\n        if (!bufs[typeIndex].length) {\r\n          bufs[typeIndex] = [[\"header\", DexSearch.typeName[type]]];\r\n        }\r\n      }\r\n\r\n      // don't match duplicate aliases\r\n      let curBufLength = passType === \"alias\" && bufs[typeIndex].length;\r\n      if (curBufLength && bufs[typeIndex][curBufLength - 1][1] === id) continue;\r\n\r\n      bufs[typeIndex].push([type, id, matchStart, matchEnd]);\r\n\r\n      count++;\r\n    }\r\n\r\n    let topbuf: SearchRow[] = [];\r\n    if (nearMatch) {\r\n      topbuf = [\r\n        [\r\n          \"html\",\r\n          `<em>No exact match found. The closest matches alphabetically are:</em>`,\r\n        ],\r\n      ];\r\n    }\r\n    if (topbufIndex >= 0) {\r\n      topbuf = topbuf.concat(bufs[topbufIndex]);\r\n      bufs[topbufIndex] = [];\r\n    }\r\n    if (searchTypeIndex >= 0) {\r\n      topbuf = topbuf.concat(bufs[0]);\r\n      topbuf = topbuf.concat(bufs[searchTypeIndex]);\r\n      bufs[searchTypeIndex] = [];\r\n      bufs[0] = [];\r\n    }\r\n\r\n    if (instafilter && count < 20) {\r\n      // Result count is less than 20, so we can instafilter\r\n      bufs.push(this.instafilter(searchType, instafilter[0], instafilter[1]));\r\n    }\r\n\r\n    this.results = Array.prototype.concat.apply(topbuf, bufs);\r\n    return this.results ?? [];\r\n  }\r\n  private instafilter(\r\n    searchType: SearchType | \"\",\r\n    fType: SearchType,\r\n    fId: ID\r\n  ): SearchRow[] {\r\n    let buf: SearchRow[] = [];\r\n    let illegalBuf: SearchRow[] = [];\r\n    let illegal = this.typedSearch?.illegalReasons;\r\n    if (searchType === \"pokemon\") {\r\n      switch (fType) {\r\n        case \"type\":\r\n          let type = (fId.charAt(0).toUpperCase() + fId.slice(1)) as TypeName;\r\n          buf.push([\"header\", `${type}-type Pok&eacute;mon`]);\r\n          for (let id in BattlePokedex) {\r\n            if (!BattlePokedex[id].types) continue;\r\n            if (BattlePokedex[id].types.includes(type)) {\r\n              (illegal && id in illegal ? illegalBuf : buf).push([\r\n                \"pokemon\",\r\n                id as ID,\r\n              ]);\r\n            }\r\n          }\r\n          break;\r\n        case \"ability\":\r\n          let ability = getID(BattleAbilities, fId).name;\r\n          buf.push([\"header\", `${ability} Pok&eacute;mon`]);\r\n          for (let id in BattlePokedex) {\r\n            if (!BattlePokedex[id].abilities) continue;\r\n            if (hasAbility(BattlePokedex[id], ability)) {\r\n              (illegal && id in illegal ? illegalBuf : buf).push([\r\n                \"pokemon\",\r\n                id as ID,\r\n              ]);\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    } else if (searchType === \"move\") {\r\n      switch (fType) {\r\n        case \"type\":\r\n          let type = fId.charAt(0).toUpperCase() + fId.slice(1);\r\n          buf.push([\"header\", `${type}-type moves`]);\r\n          for (let id in BattleMovedex) {\r\n            if (BattleMovedex[id].type === type) {\r\n              (illegal && id in illegal ? illegalBuf : buf).push([\r\n                \"move\",\r\n                id as ID,\r\n              ]);\r\n            }\r\n          }\r\n          break;\r\n        case \"category\":\r\n          let category = fId.charAt(0).toUpperCase() + fId.slice(1);\r\n          buf.push([\"header\", `${category} moves`]);\r\n          for (let id in BattleMovedex) {\r\n            if (BattleMovedex[id].category === category) {\r\n              (illegal && id in illegal ? illegalBuf : buf).push([\r\n                \"move\",\r\n                id as ID,\r\n              ]);\r\n            }\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    return [...buf, ...illegalBuf];\r\n  }\r\n\r\n  static getClosest(query: string) {\r\n    // binary search through the index!\r\n    let left = 0;\r\n    let right = BattleSearchIndex.length - 1;\r\n    while (right > left) {\r\n      let mid = Math.floor((right - left) / 2 + left);\r\n      if (\r\n        BattleSearchIndex[mid][0] === query &&\r\n        (mid === 0 || BattleSearchIndex[mid - 1][0] !== query)\r\n      ) {\r\n        // that's us\r\n        return mid;\r\n      } else if (BattleSearchIndex[mid][0] < query) {\r\n        left = mid + 1;\r\n      } else {\r\n        right = mid - 1;\r\n      }\r\n    }\r\n    if (left >= BattleSearchIndex.length - 1)\r\n      left = BattleSearchIndex.length - 1;\r\n    else if (\r\n      BattleSearchIndex[left + 1][0] &&\r\n      BattleSearchIndex[left][0] < query\r\n    )\r\n      left++;\r\n    if (left && BattleSearchIndex[left - 1][0] === query) left--;\r\n    return left;\r\n  }\r\n}\r\n\r\nabstract class BattleTypedSearch<T extends SearchType> {\r\n  searchType: T;\r\n  /**\r\n   * `species` is the second of two base filters. It constrains results to\r\n   * things that species can use, and affects the default sort.\r\n   */\r\n  species = \"\" as ID;\r\n  /**\r\n   * `set` is a pseudo-base filter; it has minor effects on move sorting.\r\n   * (Abilities/items can affect what moves are sorted as usable.)\r\n   */\r\n  set: PokemonSet | null = null;\r\n\r\n  /**\r\n   * Cached copy of what the results list would be with only base filters\r\n   * (i.e. with an empty `query` and `filters`)\r\n   */\r\n  baseResults: SearchRow[] | null = null;\r\n  /**\r\n   * Cached copy of all results not in `baseResults` - mostly in case a user\r\n   * is wondering why a specific result isn't showing up.\r\n   */\r\n  baseIllegalResults: SearchRow[] | null = null;\r\n  illegalReasons: { [id: string]: string } | null = null;\r\n  results: SearchRow[] | null = null;\r\n\r\n  protected readonly sortRow: SearchRow | null = null;\r\n\r\n  constructor(\r\n    searchType: T,\r\n    format = \"\" as ID,\r\n    speciesOrSet: ID | PokemonSet = \"\" as ID\r\n  ) {\r\n    this.searchType = searchType;\r\n\r\n    this.baseResults = null;\r\n    this.baseIllegalResults = null;\r\n\r\n    this.species = \"\" as ID;\r\n    this.set = null;\r\n    if (typeof speciesOrSet === \"string\") {\r\n      if (speciesOrSet) this.species = speciesOrSet;\r\n    } else {\r\n      this.set = speciesOrSet as PokemonSet;\r\n      this.species = toID(this.set.species);\r\n    }\r\n    if (!searchType || !this.set) return;\r\n  }\r\n  getResults(\r\n    filters?: SearchFilter[] | null,\r\n    sortCol?: string | null,\r\n    reverseSort?: boolean\r\n  ): SearchRow[] {\r\n    if (sortCol === \"type\") {\r\n      return [\r\n        this.sortRow!,\r\n        ...BattleTypeSearch.prototype.getDefaultResults.call(this),\r\n      ];\r\n    } else if (sortCol === \"category\") {\r\n      return [\r\n        this.sortRow!,\r\n        ...BattleCategorySearch.prototype.getDefaultResults.call(this),\r\n      ];\r\n    } else if (sortCol === \"ability\") {\r\n      return [\r\n        this.sortRow!,\r\n        ...BattleAbilitySearch.prototype.getDefaultResults.call(this),\r\n      ];\r\n    }\r\n\r\n    if (!this.baseResults) {\r\n      this.baseResults = this.getBaseResults();\r\n    }\r\n\r\n    if (!this.baseIllegalResults) {\r\n      const legalityFilter: { [id: string]: 1 } = {};\r\n      for (const [resultType, value] of this.baseResults) {\r\n        if (resultType === this.searchType) legalityFilter[value] = 1;\r\n      }\r\n      this.baseIllegalResults = [];\r\n      this.illegalReasons = {};\r\n\r\n      for (const id in this.getTable()) {\r\n        if (!(id in legalityFilter)) {\r\n          this.baseIllegalResults.push([this.searchType, id as ID]);\r\n          this.illegalReasons[id] = \"Illegal\";\r\n        }\r\n      }\r\n    }\r\n\r\n    let results: SearchRow[];\r\n    let illegalResults: SearchRow[] | null;\r\n\r\n    if (filters) {\r\n      results = [];\r\n      illegalResults = [];\r\n      for (const result of this.baseResults) {\r\n        if (this.filter(result, filters)) {\r\n          if (\r\n            results.length &&\r\n            result[0] === \"header\" &&\r\n            results[results.length - 1][0] === \"header\"\r\n          ) {\r\n            results[results.length - 1] = result;\r\n          } else {\r\n            results.push(result);\r\n          }\r\n        }\r\n      }\r\n      if (results.length && results[results.length - 1][0] === \"header\") {\r\n        results.pop();\r\n      }\r\n      for (const result of this.baseIllegalResults) {\r\n        if (this.filter(result, filters)) {\r\n          illegalResults.push(result);\r\n        }\r\n      }\r\n    } else {\r\n      results = [...this.baseResults];\r\n      illegalResults = null;\r\n    }\r\n\r\n    if (sortCol) {\r\n      results = results.filter(([rowType]) => rowType === this.searchType);\r\n      results = this.sort(results, sortCol, reverseSort);\r\n      if (illegalResults) {\r\n        illegalResults = illegalResults.filter(\r\n          ([rowType]) => rowType === this.searchType\r\n        );\r\n        illegalResults = this.sort(illegalResults, sortCol, reverseSort);\r\n      }\r\n    }\r\n\r\n    if (this.sortRow) {\r\n      results = [this.sortRow, ...results];\r\n    }\r\n    if (illegalResults && illegalResults.length) {\r\n      results = [...results, [\"header\", \"Illegal results\"], ...illegalResults];\r\n    }\r\n    return results;\r\n  }\r\n\r\n  abstract getTable(): { [id: string]: any };\r\n  abstract getDefaultResults(): SearchRow[];\r\n  abstract getBaseResults(): SearchRow[];\r\n  abstract filter(input: SearchRow, filters: string[][]): boolean;\r\n  abstract sort(\r\n    input: SearchRow[],\r\n    sortCol: string,\r\n    reverseSort?: boolean\r\n  ): SearchRow[];\r\n}\r\n\r\nclass BattlePokemonSearch extends BattleTypedSearch<\"pokemon\"> {\r\n  filter(row: SearchRow, filters: string[][]): boolean {\r\n    if (!filters) return true;\r\n    if (row[0] !== \"pokemon\") return true;\r\n    const poke = getID(BattlePokedex, row[1]);\r\n    for (const [filterType, value] of filters) {\r\n      switch (filterType) {\r\n        case \"type\":\r\n          if (poke.types.every((t) => t != value)) return false;\r\n          break;\r\n        case \"move\":\r\n          if (!canLearn(poke.id, value)) return false;\r\n          break;\r\n        case \"ability\":\r\n          if (!hasAbility(poke, value)) return false;\r\n          break;\r\n        case \"egggroup\":\r\n          if (poke.eggGroups.every((t) => t != value)) return false;\r\n          break;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  sortRow: SearchRow = [\"sortpokemon\", \"\"];\r\n  getTable() {\r\n    return BattlePokedex;\r\n  }\r\n  getDefaultResults(): SearchRow[] {\r\n    // Group all entries by their base species ID and then output: base followed immediately by each form.\r\n    interface Group { base: ID; num: number; forms: ID[] }\r\n    const groups: { [base: string]: Group } = {};\r\n    for (const id in BattlePokedex) {\r\n      const p = BattlePokedex[id];\r\n      if (!p) continue;\r\n      const baseId = toID(p.baseSpecies || p.name);\r\n      if (!groups[baseId]) {\r\n        groups[baseId] = { base: id as ID, num: p.num || 0, forms: [] };\r\n      }\r\n      // Identify base (prefer the entry whose name equals baseSpecies or has no forme)\r\n      const isBase = !p.forme || p.name === p.baseSpecies;\r\n      if (isBase) {\r\n        groups[baseId].base = id as ID;\r\n        groups[baseId].num = p.num || groups[baseId].num;\r\n      } else {\r\n        groups[baseId].forms.push(id as ID);\r\n      }\r\n    }\r\n    // Sort forms within each group deterministically (by name/forme)\r\n    for (const baseId in groups) {\r\n      groups[baseId].forms.sort((a, b) => {\r\n        const pa = BattlePokedex[a];\r\n        const pb = BattlePokedex[b];\r\n        const fa = (pa.forme || pa.name).toLowerCase();\r\n        const fb = (pb.forme || pb.name).toLowerCase();\r\n        return fa < fb ? -1 : fa > fb ? 1 : 0;\r\n      });\r\n    }\r\n    // Order groups by dex number then base id\r\n    const ordered = Object.values(groups).sort((a, b) => a.num - b.num || (a.base < b.base ? -1 : a.base > b.base ? 1 : 0));\r\n\r\n    // Build global form order mapping for suffix rendering in UI\r\n    (window as any).BattleFormOrder = {};\r\n    for (const g of ordered) {\r\n      (window as any).BattleFormOrder[toID(BattlePokedex[g.base].baseSpecies || BattlePokedex[g.base].name)] = g.forms.slice();\r\n    }\r\n\r\n    const results: SearchRow[] = [];\r\n    for (const g of ordered) {\r\n      const baseId = g.base;\r\n      switch (baseId) {\r\n        case \"bulbasaur\":\r\n          results.push([\"header\", \"Generation 1\"]);\r\n          break;\r\n        case \"chikorita\":\r\n          results.push([\"header\", \"Generation 2\"]);\r\n          break;\r\n        case \"treecko\":\r\n          results.push([\"header\", \"Generation 3\"]);\r\n          break;\r\n        case \"turtwig\":\r\n          results.push([\"header\", \"Generation 4\"]);\r\n          break;\r\n        case \"victini\":\r\n          results.push([\"header\", \"Generation 5\"]);\r\n          break;\r\n        case \"chespin\":\r\n          results.push([\"header\", \"Generation 6\"]);\r\n          break;\r\n        case \"rowlet\":\r\n          results.push([\"header\", \"Generation 7\"]);\r\n          break;\r\n        case \"grookey\":\r\n          results.push([\"header\", \"Generation 8\"]);\r\n          break;\r\n        case \"sprigatito\":\r\n          results.push([\"header\", \"Generation 9\"]);\r\n          break;\r\n        case \"missingno\":\r\n          results.push([\"header\", \"Glitch\"]);\r\n          break;\r\n        case \"syclar\":\r\n          results.push([\"header\", \"CAP\"]);\r\n          break;\r\n        case \"pikachucosplay\":\r\n          continue; // skip cosplay aggregate\r\n      }\r\n      results.push([\"pokemon\", baseId]);\r\n      for (const fid of g.forms) {\r\n        results.push([\"pokemon\", fid]);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  getBaseResults(): SearchRow[] {\r\n    return this.getDefaultResults();\r\n  }\r\n  sort(results: SearchRow[], sortCol: string, reverseSort?: boolean) {\r\n    const sortOrder = reverseSort ? -1 : 1;\r\n    if ([\"hp\", \"atk\", \"def\", \"spa\", \"spd\", \"spe\"].includes(sortCol)) {\r\n      return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n        const stat1 = getID(BattlePokedex, id1).baseStats[sortCol];\r\n        const stat2 = getID(BattlePokedex, id2).baseStats[sortCol];\r\n        return (stat2 - stat1) * sortOrder;\r\n      });\r\n    } else if (sortCol === \"bst\") {\r\n      return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n        const base1 = getID(BattlePokedex, id1).baseStats;\r\n        const base2 = getID(BattlePokedex, id2).baseStats;\r\n        const bst1 =\r\n          base1.hp + base1.atk + base1.def + base1.spa + base1.spd + base1.spe;\r\n        const bst2 =\r\n          base2.hp + base2.atk + base2.def + base2.spa + base2.spd + base2.spe;\r\n        return (bst2 - bst1) * sortOrder;\r\n      });\r\n    } else if (sortCol === \"name\") {\r\n      return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n        const name1 = id1;\r\n        const name2 = id2;\r\n        return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\r\n      });\r\n    }\r\n    throw new Error(\"invalid sortcol\");\r\n  }\r\n}\r\n\r\nclass BattleAbilitySearch extends BattleTypedSearch<\"ability\"> {\r\n  getTable() {\r\n    return BattleAbilities;\r\n  }\r\n  getDefaultResults(): SearchRow[] {\r\n    const results: SearchRow[] = [];\r\n    for (let id in BattleAbilities) {\r\n      results.push([\"ability\", id as ID]);\r\n    }\r\n    return results;\r\n  }\r\n  getBaseResults() {\r\n    return this.getDefaultResults();\r\n  }\r\n  filter(row: SearchRow, filters: string[][]) {\r\n    if (!filters) return true;\r\n    if (row[0] !== \"ability\") return true;\r\n    const ability = getID(BattleAbilities, row[1]);\r\n    for (const [filterType, value] of filters) {\r\n      switch (filterType) {\r\n        case \"pokemon\":\r\n          if (!hasAbility(getID(BattlePokedex, value), ability.name))\r\n            return false;\r\n          break;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  sort(\r\n    results: SearchRow[],\r\n    sortCol: string | null,\r\n    reverseSort?: boolean\r\n  ): SearchRow[] {\r\n    throw new Error(\"invalid sortcol\");\r\n  }\r\n}\r\n\r\nclass BattleItemSearch extends BattleTypedSearch<\"item\"> {\r\n  getTable() {\r\n    return BattleItems;\r\n  }\r\n  getDefaultResults(): SearchRow[] {\r\n    let results: SearchRow[] = [];\r\n    results.push([\"header\", \"Items\"]);\r\n    for (let id in BattleItems) {\r\n      results.push([\"item\", id as ID]);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  getBaseResults(): SearchRow[] {\r\n    return this.getDefaultResults();\r\n  }\r\n  filter(row: SearchRow, filters: string[][]): boolean {\r\n    throw new Error(\"invalid filter\");\r\n  }\r\n  sort(\r\n    results: SearchRow[],\r\n    sortCol: string | null,\r\n    reverseSort?: boolean\r\n  ): SearchRow[] {\r\n    throw new Error(\"invalid sortcol\");\r\n  }\r\n}\r\n\r\nclass BattleMoveSearch extends BattleTypedSearch<\"move\"> {\r\n  sortRow: SearchRow = [\"sortmove\", \"\"];\r\n  getTable() {\r\n    return BattleMovedex;\r\n  }\r\n  getDefaultResults(): SearchRow[] {\r\n    let results: SearchRow[] = [];\r\n    results.push([\"header\", \"Moves\"]);\r\n    for (let id in BattleMovedex) {\r\n      results.push([\"move\", id as ID]);\r\n    }\r\n    return results;\r\n  }\r\n\r\n  getBaseResults() {\r\n    return this.getDefaultResults();\r\n  }\r\n\r\n  filter(row: SearchRow, filters: string[][]) {\r\n    if (!filters) return true;\r\n    if (row[0] !== \"move\") return true;\r\n    const move = getID(BattleMovedex, row[1]);\r\n    for (const [filterType, value] of filters) {\r\n      switch (filterType) {\r\n        case \"type\":\r\n          if (move.type !== value) return false;\r\n          break;\r\n        case \"category\":\r\n          if (move.category !== value) return false;\r\n          break;\r\n        case \"pokemon\":\r\n          if (!canLearn(value as ID, move.id)) return false;\r\n          break;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  sort(\r\n    results: SearchRow[],\r\n    sortCol: string,\r\n    reverseSort?: boolean\r\n  ): SearchRow[] {\r\n    const sortOrder = reverseSort ? -1 : 1;\r\n    switch (sortCol) {\r\n      case \"power\":\r\n        let powerTable: { [id: string]: number | undefined } = {\r\n          return: 102,\r\n          frustration: 102,\r\n          spitup: 300,\r\n          trumpcard: 200,\r\n          naturalgift: 80,\r\n          grassknot: 120,\r\n          lowkick: 120,\r\n          gyroball: 150,\r\n          electroball: 150,\r\n          flail: 200,\r\n          reversal: 200,\r\n          present: 120,\r\n          wringout: 120,\r\n          crushgrip: 120,\r\n          heatcrash: 120,\r\n          heavyslam: 120,\r\n          fling: 130,\r\n          magnitude: 150,\r\n          beatup: 24,\r\n          punishment: 1020,\r\n          psywave: 1250,\r\n          nightshade: 1200,\r\n          seismictoss: 1200,\r\n          dragonrage: 1140,\r\n          sonicboom: 1120,\r\n          superfang: 1350,\r\n          endeavor: 1399,\r\n          sheercold: 1501,\r\n          fissure: 1500,\r\n          horndrill: 1500,\r\n          guillotine: 1500,\r\n        };\r\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n          let move1 = getID(BattleMovedex, id1);\r\n          let move2 = getID(BattleMovedex, id2);\r\n          let pow1 =\r\n            move1.basePower ||\r\n            powerTable[id1] ||\r\n            (move1.category === \"Status\" ? -1 : 1400);\r\n          let pow2 =\r\n            move2.basePower ||\r\n            powerTable[id2] ||\r\n            (move2.category === \"Status\" ? -1 : 1400);\r\n          return (pow2 - pow1) * sortOrder;\r\n        });\r\n      case \"accuracy\":\r\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n          let accuracy1 = getID(BattleMovedex, id1).accuracy || 0;\r\n          let accuracy2 = getID(BattleMovedex, id2).accuracy || 0;\r\n          if (accuracy1 === true) accuracy1 = 101;\r\n          if (accuracy2 === true) accuracy2 = 101;\r\n          return (accuracy2 - accuracy1) * sortOrder;\r\n        });\r\n      case \"pp\":\r\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n          let pp1 = getID(BattleMovedex, id1).pp || 0;\r\n          let pp2 = getID(BattleMovedex, id2).pp || 0;\r\n          return (pp2 - pp1) * sortOrder;\r\n        });\r\n      case \"name\":\r\n        return results.sort(([rowType1, id1], [rowType2, id2]) => {\r\n          const name1 = id1;\r\n          const name2 = id2;\r\n          return (name1 < name2 ? -1 : name1 > name2 ? 1 : 0) * sortOrder;\r\n        });\r\n    }\r\n    throw new Error(\"invalid sortcol\");\r\n  }\r\n}\r\n\r\nclass BattleCategorySearch extends BattleTypedSearch<\"category\"> {\r\n  getTable() {\r\n    return { physical: 1, special: 1, status: 1 };\r\n  }\r\n  getDefaultResults(): SearchRow[] {\r\n    return [\r\n      [\"category\", \"physical\" as ID],\r\n      [\"category\", \"special\" as ID],\r\n      [\"category\", \"status\" as ID],\r\n    ];\r\n  }\r\n  getBaseResults() {\r\n    return this.getDefaultResults();\r\n  }\r\n  filter(row: SearchRow, filters: string[][]): boolean {\r\n    throw new Error(\"invalid filter\");\r\n  }\r\n  sort(\r\n    results: SearchRow[],\r\n    sortCol: string | null,\r\n    reverseSort?: boolean\r\n  ): SearchRow[] {\r\n    throw new Error(\"invalid sortcol\");\r\n  }\r\n}\r\n\r\nclass BattleTypeSearch extends BattleTypedSearch<\"type\"> {\r\n  getTable() {\r\n    return BattleTypeChart;\r\n  }\r\n  getDefaultResults(): SearchRow[] {\r\n    const results: SearchRow[] = [];\r\n    for (let id in BattleTypeChart) {\r\n      results.push([\"type\", id as ID]);\r\n    }\r\n    return results;\r\n  }\r\n  getBaseResults() {\r\n    return this.getDefaultResults();\r\n  }\r\n  filter(row: SearchRow, filters: string[][]): boolean {\r\n    throw new Error(\"invalid filter\");\r\n  }\r\n  sort(\r\n    results: SearchRow[],\r\n    sortCol: string | null,\r\n    reverseSort?: boolean\r\n  ): SearchRow[] {\r\n    throw new Error(\"invalid sortcol\");\r\n  }\r\n}\r\n\r\n\r\nexport {}\r\ndeclare global {\r\n  interface Window {\r\n    DexSearch: typeof DexSearch;\r\n  }\r\n}\r\nwindow.DexSearch = DexSearch;\r\n"],"names":["$978dcbb073010154$var$BattleSearchIndexOffset","$978dcbb073010154$var$BattleSearchIndex","$978dcbb073010154$var$hasAbility","pokemon","ability","key","abilities","toID","$978dcbb073010154$var$DexSearch","typeTable","type","tier","move","item","egggroup","category","article","typeName","searchType","formatid","species","index","query","typedSearch","results","exactMatch","firstPokemonColumn","sortCol","reverseSort","filters","concat","Object","keys","BattlePokedex","map","x","BattleMovedex","BattleItems","BattleAbilities","BattleTypeChart","sort","indexOf","getID","split","length","Number","entry","i","id","name","res","nonAlnum","j","test","setType","getTypedSearch","format","speciesOrSet","$978dcbb073010154$var$BattlePokemonSearch","$978dcbb073010154$var$BattleItemSearch","$978dcbb073010154$var$BattleMoveSearch","$978dcbb073010154$var$BattleAbilitySearch","$978dcbb073010154$var$BattleTypeSearch","$978dcbb073010154$var$BattleCategorySearch","find","textSearch","getResults","addFilter","includes","filter","push","removeFilter","filterid","join","deleted","splice","pop","toggleSort","filterLabel","filterType","illegalLabel","illegalReasons","searchTypeIndex","qFilterType","slice","getClosest","passType","searchPasses","substr","matchLength","matchQuery","bufs","topbufIndex","count","nearMatch","instafilter","instafilterSort","illegal","searchPass","shift","typeIndex","startsWith","matchStart","matchEnd","originalIndex","charCodeAt","curBufLength","topbuf","Array","prototype","apply","fType","fId","buf","illegalBuf","charAt","toUpperCase","types","type1","left","right","mid","Math","floor","$978dcbb073010154$var$BattleTypedSearch","set","baseResults","baseIllegalResults","sortRow","illegalResults","getDefaultResults","call","getBaseResults","legalityFilter","resultType","value","getTable","result","rowType","row","poke","every","t","canLearn","eggGroups","groups","p","baseId","baseSpecies","base","num","forms","forme","a","b","pa","pb","fa","toLowerCase","fb","ordered","values","g","window","BattleFormOrder","fid","sortOrder","rowType1","id1","rowType2","id2","stat1","baseStats","stat2","base1","base2","bst1","hp","atk","def","spa","spd","spe","bst2","name1","Error","args","powerTable","return","frustration","spitup","trumpcard","naturalgift","grassknot","lowkick","gyroball","electroball","flail","reversal","present","wringout","crushgrip","heatcrash","heavyslam","fling","magnitude","beatup","punishment","psywave","nightshade","seismictoss","dragonrage","sonicboom","superfang","endeavor","sheercold","fissure","horndrill","guillotine","move1","move2","pow1","basePower","pow2","accuracy1","accuracy","accuracy2","pp1","pp","pp2","physical","special","status","DexSearch"],"version":3,"file":"Binary-Star-Pokedex.a7eb0a5e.js.map"}